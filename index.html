<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glacier Crawler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Montserrat', sans-serif; user-select: none; touch-action: none; }

        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; touch-action: none; }

        /* OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(2, 2, 5, 0.95);
            z-index: 10; color: white; transition: opacity 0.2s; backdrop-filter: blur(5px);
        }   
        .hidden { display: none !important; }

        h1 { font-size: 70px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 5px; color: #fff; text-shadow: 0 0 20px #00f2fe, 0 0 40px #00f2fe; }
        h2 { color: #00f2fe; margin-bottom: 50px; font-weight: 900; text-shadow: 0 0 10px #00f2fe; }

        .menu-btn {
            background: rgba(0,0,0,0.8); color: #fff;
            font-family: 'Montserrat', sans-serif; font-size: 18px; font-weight: 700;
            padding: 15px 40px; margin: 10px; /* Even Spacing */
            border: 2px solid #fff; cursor: pointer; width: 320px;
            text-align: center; transition: 0.1s; box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        .menu-btn:hover { background: #fff; color: #000; border-color: #00f2fe; transform: scale(1.02); box-shadow: 0 0 20px #00f2fe; }

        /* HUD */
        #hud { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 5; }
        .bar-wrap { width: 350px; height: 16px; background: #0a0a0a; margin-bottom: 10px; border: 2px solid #444; box-shadow: 0 0 10px #000; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s linear; }
        #hp-fill { background: #ff2a6d; box-shadow: 0 0 10px #ff2a6d; }
        #xp-fill { background: #00f2fe; width: 0%; box-shadow: 0 0 10px #00f2fe; }

        .depth-info { font-size: 24px; color: #00ffaa; letter-spacing: 2px; margin-bottom: 5px; font-weight: 900; text-shadow: 0 0 10px #00ffaa; }
        .wave-info { font-size: 18px; color: #ff9900; font-weight: 700; margin-top:5px; }

        #fps-counter { position: absolute; top: 20px; right: 20px; color: #00ffaa; font-weight: bold; font-family: monospace; z-index: 5; display: none; }

        #version-badge { position: absolute; bottom: 20px; left: 20px; color: #666; font-size: 14px; font-weight: 400; z-index: 11; pointer-events: none; }

        /* SKILLS */
        #skills-row { display: flex; gap: 15px; margin-top: 20px; pointer-events: auto; }
        .skill-box {
            width: 60px; height: 60px; background: #0a0a0f; border: 2px solid #333;
            position: relative; display: none; justify-content: center; align-items: center;
            transition: all 0.2s;
        }
        .skill-box.cooling { border-color: #444; box-shadow: inset 0 0 0 2px rgba(0,0,0,0.6); filter: saturate(0.7) brightness(0.85); }
        .skill-box.ready { border-color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.4); transform: scale(1.05); }
        .skill-key { position: absolute; top: -10px; left: -5px; background: #000; border: 1px solid #666; font-size: 10px; padding: 2px 5px; color: #fff; font-weight: bold; z-index: 4; }
        .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 3; transition: height 0.08s linear, opacity 0.12s linear; opacity: 0.95; }
        .skill-box.cooling .cooldown-overlay {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.88), rgba(0, 242, 254, 0.18));
            border-top: 2px solid rgba(0, 242, 254, 0.55);
            box-shadow: inset 0 12px 22px rgba(0,0,0,0.65);
        }
        .skill-box.ready .cooldown-overlay { opacity: 0; }
        
        .ico-shock { width: 24px; height: 24px; border-radius: 50%; border: 3px solid #00f2fe; box-shadow: 0 0 10px #00f2fe; }
        .ico-mag { 
            width: 26px; height: 26px;
            position: relative;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 50%, rgba(0, 242, 254, 0.95) 0%, rgba(0, 242, 254, 0.22) 35%, rgba(0, 0, 0, 0) 62%);
            border: 2px solid rgba(0, 242, 254, 0.9);
            box-shadow: 0 0 14px rgba(0, 242, 254, 0.75), inset 0 0 10px rgba(0, 242, 254, 0.35);
        }
        .ico-mag::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.75);
            transform: translate(-50%, -50%) scaleX(1.08) rotate(20deg);
            box-shadow: 0 0 8px rgba(255,255,255,0.35);
        }
        .ico-mag::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.92);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.55);
        }
        .ico-shield { width: 22px; height: 22px; border: 4px solid #00ffaa; border-radius: 50%; box-shadow: 0 0 10px #00ffaa; background: rgba(0, 255, 170, 0.2); }
        .ico-multi { width: 6px; height: 18px; background: #ff9900; box-shadow: 10px 0 0 #ff9900, -10px 0 0 #ff9900, 0 0 10px #ff9900; }

        /* MODALS */
        .modal-content { background: #050508; border: 2px solid #00f2fe; padding: 40px; text-align: center; max-width: 900px; width: 90%; box-shadow: 0 0 50px rgba(0, 242, 254, 0.2); }
        .ans-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; }
        .upgrade-btn { border: 1px solid #555; padding: 25px; background: #111; cursor: pointer; text-align: left; position: relative; transition: 0.2s; }
        .upgrade-btn:hover { border-color: #00f2fe; background: #1a1a20; transform: translateY(-5px); box-shadow: 0 0 15px rgba(0, 242, 254, 0.2); }
        .u-title { color: #ffd700; font-size: 24px; margin-bottom: 8px; font-weight: 900; }
        .u-desc { color: #aaa; font-size: 15px; line-height: 1.4; }
        .u-tag { position: absolute; top: 10px; right: 10px; font-size: 10px; background: #333; padding: 3px 8px; border-radius: 4px; color: #fff; }
        .unlock-btn { border-color: #ff00de; } .unlock-btn .u-title { color: #ff00de; }

        /* TRIVIA */
        #trivia-overlay { background: rgba(0,0,0,0.95); }
        .trivia-box { width: 700px; background: #0a0a0f; border: 2px solid #fff; padding: 30px; text-align: center; box-shadow: 0 0 30px rgba(255,255,255,0.1); }
        .t-ques { font-size: 24px; margin-bottom: 30px; color: #fff; font-weight: 700; line-height: 1.4; }
        .t-opts { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .t-btn { background: #111; border: 1px solid #555; color: #fff; padding: 20px; font-size: 16px; cursor: pointer; font-weight: bold; transition:0.2s; min-height: 110px; display: flex; align-items: center; justify-content: center; text-align: center; }
        .t-btn-text { display: block; width: 100%; }
        .t-btn:hover { background: #15151c; color: #fff; border-color: #00f2fe; box-shadow: 0 0 16px rgba(0, 242, 254, 0.18); }
        .t-btn.disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
        .t-status { font-size: 16px; color: #ff2a6d; margin-bottom: 15px; height: 20px; letter-spacing: 2px; font-weight: 900; }

        .gloss-term { color: #00f2fe; cursor: help; text-shadow: 0 0 8px rgba(0, 242, 254, 0.35); transition: 0.12s; }
        .gloss-term:hover { color: #fff; text-shadow: 0 0 14px rgba(0, 242, 254, 0.8); }
        #glossary-tooltip { position: fixed; left: 0; top: 0; max-width: 320px; padding: 12px 14px; background: rgba(5, 5, 8, 0.98); border: 1px solid #00f2fe; box-shadow: 0 0 25px rgba(0, 242, 254, 0.25); color: #fff; z-index: 2000; opacity: 0; transform: translateY(6px); pointer-events: none; transition: opacity 0.12s, transform 0.12s; }
        #glossary-tooltip.show { opacity: 1; transform: translateY(0px); }
        #glossary-tooltip .gt-title { font-weight: 900; letter-spacing: 1px; color: #00f2fe; margin-bottom: 6px; }
        #glossary-tooltip .gt-body { color: #ddd; font-size: 14px; line-height: 1.35; }

        /* PAUSE & SETTINGS */
        #pause-content, #settings-content {
            background: #0a0a0f; border: 1px solid #444; padding: 40px; width: 600px;
            display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px;
            align-items: center; /* Centered buttons */
        }
        #pause-content { display: grid; grid-template-columns: 1fr 1fr; align-items: start; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 16px; color: #ccc; border-bottom: 1px solid #222; padding-bottom: 5px; }
        .stat-val { font-weight: bold; color: #fff; }
        
        /* LEARN CARDS */
        .fact-card { 
            background: rgba(20,20,30, 0.9); border: 1px solid #444; padding: 30px; 
            cursor: pointer; transition: all 0.2s; position: relative; min-height: 120px;
            display: flex; flex-direction: column; justify-content: center;
        }
        .fact-card:hover { border-color: #00f2fe; background: rgba(30,30,40,1); }
        .fact-card.revealed { border-color: #00f2fe; background: #051a24; }
        .fact-a-wrap { margin-top: 15px; border-top: 1px solid #333; padding-top: 15px; display: none; }
        .revealed .fact-a-wrap { display: block; }

        /* TRANSITION SCREEN */
        #depth-screen {
            background: #000;
        }
        
        /* ZONE INTRO SCREEN */
        #zone-intro {
            background: rgba(0,0,0,0.98);
        }
        .zone-content {
            background: #0a0a0f;
            border: 2px solid #00f2fe;
            padding: 40px;
            max-width: 900px;
            width: 80%;
            box-shadow: 0 0 50px rgba(0, 242, 254, 0.3);
            text-align: center;
        }
        .zone-title {
            font-size: 48px;
            color: #00f2fe;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 15px #00f2fe;
        }
        .zone-description {
            font-size: 20px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #333;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            text-align: left;
        }
        .continue-prompt {
            font-size: 18px;
            color: #00ffaa;
            margin-top: 30px;
            animation: pulse 1.5s infinite;
            text-shadow: 0 0 10px #00ffaa;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* --- DEV CONSOLE STYLES --- */
        #dev-console {
            position: absolute; top: 10px; right: 10px; width: 300px;
            background: rgba(0, 0, 0, 0.9); border: 1px solid #00f2fe;
            color: #00f2fe; font-family: monospace; z-index: 1000;
            padding: 15px; display: none; box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
        }
        #dev-console h3 { margin: 0 0 10px 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .dev-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; }
        .dev-input { width: 60px; background: #111; border: 1px solid #555; color: #fff; padding: 2px; }
        .dev-btn { width: 100%; background: #222; border: 1px solid #00f2fe; color: #fff; padding: 5px; cursor: pointer; margin-top: 5px; font-family: monospace; }
        .dev-btn:hover { background: #00f2fe; color: #000; }
        .dev-chk { cursor: pointer; }
        
        /* ARCHIVE TABS */
        .archive-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .archive-tab {
            background: #111;
            border: 1px solid #444;
            color: #ccc;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            font-weight: bold;
        }
        .archive-tab:hover {
            background: #222;
            border-color: #00f2fe;
        }
        .archive-tab.active {
            background: #00f2fe;
            color: #000;
            border-color: #00f2fe;
            box-shadow: 0 0 10px #00f2fe;
        }
        .archive-content {
            display: none;
            width: 80%;
            overflow-y: auto;
            max-height: 60vh;
            padding-bottom: 50px;
        }
        .archive-content.active {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .archive-blurbs {
            width: 80%;
            overflow-y: auto;
            max-height: 60vh;
            padding-bottom: 50px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .archive-section {
            width: 100%;
            text-align: left;
            background: rgba(20,20,30, 0.9);
            border: 1px solid #333;
            padding: 22px;
        }
        .archive-section-title {
            color: #00f2fe;
            font-weight: 900;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 12px;
            font-size: 18px;
        }
        .archive-section-body { color: #ddd; font-size: 16px; line-height: 1.55; }
        .archive-section-body ul { margin: 12px 0 0 18px; padding: 0; }
        .archive-section-body li { margin: 8px 0; }
        .question-count {
            color: #00ffaa;
            font-size: 14px;
            margin-left: 10px;
        }
        
        /* ZOOM CONTROLS */
        .zoom-slider {
            width: 100%;
            height: 20px;
            margin: 10px 0;
            background: #111;
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #00f2fe;
            cursor: pointer;
            box-shadow: 0 0 10px #00f2fe;
        }
        .zoom-preview {
            width: 200px;
            height: 150px;
            margin: 20px auto;
            border: 2px solid #00f2fe;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00f2fe;
            font-size: 14px;
        }
        .zoom-value {
            color: #00f2fe;
            font-weight: bold;
            margin-top: 5px;
        }
        
        /* MOUSE TYPE SELECTOR */
        .mouse-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            width: 100%;
        }
        .mouse-option {
            padding: 20px;
            background: #111;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .mouse-option:hover {
            border-color: #00f2fe;
            background: #1a1a20;
        }
        .mouse-option.active {
            border-color: #00f2fe;
            background: rgba(0, 242, 254, 0.1);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.3);
        }
        .mouse-preview {
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 30px;
        }
        .mouse-preview.crosshair { color: #fff; }
        .mouse-preview.pointer { color: #00f2fe; }
        .mouse-preview.circle { color: #fff; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="fps-counter">FPS: 60</div>

    <div id="dev-console">
        <h3>DEV CONSOLE (Toggle: \)</h3>
        
        <div class="dev-row">
            <span>GOD MODE (No CD/Dmg)</span>
            <input type="checkbox" id="dev-god" class="dev-chk">
        </div>
        <div class="dev-row">
            <span>DISABLE TRIVIA</span>
            <input type="checkbox" id="dev-trivia" class="dev-chk">
        </div>
        
        <div style="margin-top:10px; color:#aaa; font-size:12px;">PLAYER STATS</div>
        <div class="dev-row">
            <span>Damage</span>
            <input type="number" id="dev-dmg" class="dev-input" onchange="updatePlayerStat('dmg', this.value)">
        </div>
        <div class="dev-row">
            <span>Fire Rate (frames)</span>
            <input type="number" id="dev-fr" class="dev-input" onchange="updatePlayerStat('fr', this.value)">
        </div>
        <div class="dev-row">
            <span>Speed</span>
            <input type="number" id="dev-spd" class="dev-input" onchange="updatePlayerStat('spd', this.value)">
        </div>
        <div class="dev-row">
            <span>Bullet Speed</span>
            <input type="number" id="dev-bspd" class="dev-input" onchange="updatePlayerStat('bulletSpd', this.value)">
        </div>

        <div style="margin-top:10px; color:#aaa; font-size:12px;">NAVIGATION</div>
        <button class="dev-btn" onclick="devInstantLevel()">INSTANT LEVEL UP</button>
        <button class="dev-btn" onclick="devSkipWave()">SKIP WAVE (KILL ALL)</button>
        <button class="dev-btn" onclick="devNextZone()">NEXT ZONE (TELEPORT)</button>
        <button class="dev-btn" onclick="devUnlockAll()">UNLOCK ALL MODULES</button>
    </div>

    <!-- ZONE INTRODUCTION SCREEN -->
    <div id="zone-intro" class="overlay hidden">
        <div class="zone-content">
            <div class="zone-title" id="zone-title">ZONE NAME</div>
            <div class="zone-description" id="zone-description">
                Loading zone description...
            </div>
            <div class="continue-prompt" id="zone-continue">Press ANY KEY or CLICK to continue...</div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>GLACIER CRAWLER</h1>
        <h2 style="font-size: 24px; letter-spacing: 2px;">DEEP DIVE PROTOCOL</h2>
        <button class="menu-btn" onclick="startGame()">INITIATE</button>
        <button class="menu-btn" onclick="openSettings('MENU')">SETTINGS</button>
        <button class="menu-btn" onclick="showLearn()">ARCHIVE</button>
        <div id="version-badge">v1.8</div>
    </div>

    <div id="settings-screen" class="overlay hidden">
        <h1>SETTINGS</h1>
        <div id="settings-content">
            <!-- GRAPHICS QUALITY -->
            <h3 style="color:#00f2fe; margin-top: 0; width: 100%; text-align: center;">GRAPHICS QUALITY</h3>
            <button class="menu-btn" id="btn-bloom" onclick="toggleBloom()" style="margin:0; width:100%">
                EFFECTS: LOW
            </button>
            <button class="menu-btn" id="btn-fps" onclick="toggleFps()" style="margin:0; width:100%">FPS: OFF</button>
            
            <!-- MOUSE TYPE SELECTOR -->
            <h3 style="color:#00f2fe; margin-top: 30px; width: 100%; text-align: center;">MOUSE TYPE</h3>
            <div class="mouse-type-selector">
                <div class="mouse-option active" onclick="changeMouseType('crosshair')">
                    <div class="mouse-preview crosshair">+</div>
                    <div>Crosshair</div>
                </div>
                <div class="mouse-option" onclick="changeMouseType('pointer')">
                    <div class="mouse-preview pointer">☝</div>
                    <div>Pointer</div>
                </div>
                <div class="mouse-option" onclick="changeMouseType('circle')">
                    <div class="mouse-preview circle">○</div>
                    <div>Circle</div>
                </div>
            </div>
        </div>
        <button class="menu-btn" onclick="closeSettings()">BACK</button>
    </div>

    <div id="win-screen" class="overlay hidden">
        <h1 style="color: #00ffaa; font-size: 80px; text-shadow: 0 0 30px #00ffaa;">MISSION COMPLETE</h1>
        <h2 style="color: #fff;">GLACIER CONQUERED</h2>
        <div style="color: #ccc; margin-bottom: 30px; font-size: 18px;">ALL SAMPLES COLLECTED</div>
        <button class="menu-btn" onclick="startGame()">RESTART</button>
        <button class="menu-btn" onclick="goHome()">MAIN MENU</button>
    </div>

    <div id="depth-screen" class="overlay hidden">
        <h1 id="depth-title" style="font-size:60px;">ZONE 1</h1>
        <h2 id="depth-sub" style="color:#aaa;">ENTERING...</h2>
    </div>

    <div id="pause-screen" class="overlay hidden">
        <h1>SYSTEM PAUSED</h1>
        <div id="pause-content">
            <div>
                <h3 style="color:#00f2fe; border-bottom:2px solid #00f2fe; padding-bottom:10px;">STATS</h3>
                <div class="stat-row"><span>Damage</span><span class="stat-val" id="st-dmg">0</span></div>
                <div class="stat-row"><span>Fire Rate</span><span class="stat-val" id="st-fr">0</span></div>
                <div class="stat-row"><span>Speed</span><span class="stat-val" id="st-spd">0</span></div>
                <div class="stat-row"><span>Max HP</span><span class="stat-val" id="st-hp">0</span></div>
            </div>
            <div>
                <h3 style="color:#ff00de; border-bottom:2px solid #ff00de; padding-bottom:10px;">MODULES</h3>
                <div id="st-mods"></div>
            </div>
        </div>
        <button class="menu-btn" onclick="togglePause()">RESUME</button>
        <button class="menu-btn" onclick="openSettings('PAUSE')">SETTINGS</button>
        <button class="menu-btn" onclick="showLearn()">ARCHIVE</button>
        <button class="menu-btn" style="width:200px; padding:15px; margin-top:0;" onclick="goHome()">QUIT</button>
    </div>

    <div id="learn-screen" class="overlay hidden">
        <h1 style="font-size: 40px; margin-bottom: 20px;">GLACIER ARCHIVE</h1>
        <div style="margin-bottom:10px; color:#aaa">ZONE BRIEFS + DEFINITIONS</div>
        
        <!-- TAB NAVIGATION -->
        <div id="archive-container" class="archive-blurbs"></div>
        
        <button class="menu-btn" onclick="goBackFromArchive()">BACK</button>
    </div>

    <div id="death-screen" class="overlay hidden">
        <h1 style="color: #ff2a6d;">HULL CRITICAL</h1>
        <h2 id="final-score"></h2>
        <button class="menu-btn" onclick="startGame()">REBOOT</button>
        <button class="menu-btn" onclick="goHome()">MAIN MENU</button>
    </div>

    <div id="hud" class="hidden">
        <div class="depth-info" id="level-tag">ZONE OF ACCUMULATION</div>
        <div class="wave-info" id="wave-tag">WAVE 1/10</div>
        
        <div class="bar-wrap" style="margin-top:15px;"><div id="hp-fill" class="bar-fill"></div></div>
        <div class="bar-wrap" style="border-color:#005566; height:10px;"><div id="xp-fill" class="bar-fill"></div></div>
        <div style="font-size:14px; color:#888; font-weight: bold; margin-top:5px;">LVL <span id="lvl-txt" style="color:#fff; font-size:18px;">1</span></div>

        <div id="skills-row">
            <div id="skill-shock" class="skill-box"><div class="skill-key">SPC</div><div class="ico-shock"></div><div id="cd-shock" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-mag" class="skill-box"><div class="skill-key">Q</div><div class="ico-mag"></div><div id="cd-mag" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-multi" class="skill-box"><div class="skill-key">E</div><div class="ico-multi"></div><div id="cd-multi" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-shield" class="skill-box"><div class="ico-shield"></div><div id="cd-shield" class="cooldown-overlay" style="height:100%"></div></div>
        </div>
    </div>

    <div id="trivia-overlay" class="overlay hidden">
        <div class="trivia-box">
            <div style="color:#00f2fe; margin-bottom:10px; font-weight:900; letter-spacing:2px">LEVEL UP PROTOCOL</div>
            <div class="t-status" id="t-status"></div>
            <div class="t-ques" id="t-ques">?</div>
            <div class="t-opts" id="t-opts"></div>
            <div style="margin-top:20px; font-size:12px; color:#666;">CORRECT: UPGRADE<br>WRONG: TRY AGAIN NEXT LEVEL</div>
        </div>
    </div>

    <div id="glossary-tooltip"></div>

    <div id="upgrade-overlay" class="overlay hidden">
        <div class="modal-content">
            <h2 id="up-header" style="color:#fff; font-size:50px; margin-bottom: 10px;">SYSTEM UPGRADE</h2>
            <div class="ans-grid" id="up-container"></div>
        </div>
    </div>

</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const screens = {
    start: document.getElementById('start-screen'),
    death: document.getElementById('death-screen'),
    win: document.getElementById('win-screen'),
    settings: document.getElementById('settings-screen'),
    hud: document.getElementById('hud'),
    upgrade: document.getElementById('upgrade-overlay'),
    trivia: document.getElementById('trivia-overlay'),
    pause: document.getElementById('pause-screen'),
    learn: document.getElementById('learn-screen'),
    depth: document.getElementById('depth-screen'),
    zoneIntro: document.getElementById('zone-intro')
};

// CONSTANTS
const ROOM_WIDTH = 2400; // Large Arena
const ROOM_HEIGHT = 1800;
const WAVES_PER_DEPTH = 10;
const MAX_PARTICLES = 200; // Increased for better coverage
const SNOW_PARTICLES = []; // Separate array for snow particles
const MAX_XP = 300; // Performance Cap

const DEPTH_NAMES = [
    "ZONE OF ACCUMULATION",
    "EQUILIBRIUM LINE",
    "CREVASSES",
    "LANDFORMS & CIRQUE",
    "ZONE OF ABLATION",
    "MORAINE DEPOSITS"
];

// Zone descriptions for educational intros
const ZONE_DESCRIPTIONS = [
    `The <span style="color:#00f2fe">Zone of Accumulation</span> is where snowfall exceeds melting. Fresh snow compresses into firn and eventually glacial ice through pressure. This zone is characterized by positive mass balance and serves as the glacier's "fuel tank." The snowline marks the boundary between accumulation and ablation zones.`,
    
    `The <span style="color:#00f2fe">Equilibrium Line</span> represents the altitude where accumulation equals ablation annually. Below this line, the glacier loses mass; above it, gains mass. This dynamic balance point fluctuates with climate conditions and is critical for predicting glacier health and behavior.`,
    
    `<span style="color:#00f2fe">Crevasses</span> are deep fractures in glacial ice caused by tensile stress. They form when ice moves over uneven terrain or changes velocity. Despite appearances, crevasses rarely extend beyond 50 meters deep due to plastic ice flow under pressure. They're navigation hazards but important for studying internal glacier structure.`,
    
    `Glacial <span style="color:#00f2fe">Landforms</span> like cirques, aretes, and horns result from erosional processes. A cirque is an amphitheater-shaped basin carved by ice accumulation and rotational sliding. When multiple cirques converge, they create distinctive sharp ridges and pyramidal peaks that define alpine landscapes.`,
    
    `The <span style="color:#00f2fe">Zone of Ablation</span> is where ice loss exceeds accumulation through melting, sublimation, and calving. Ablation processes include surface melt, basal melt from geothermal heat, and frontal ablation at glacier termini. This zone determines a glacier's net mass balance and retreat rate.`,
    
    `<span style="color:#00f2fe">Moraines</span> are accumulations of glacially transported debris. Terminal moraines mark maximum ice extent, lateral moraines form along glacier edges, and medial moraines result from merging glaciers. These deposits preserve climate history and influence post-glacial ecosystems.`
];

// STATE
let gameState="MENU", previousState="MENU"; 
let gameSettings = { 
    bloom: false, 
    fps: false,
    mouseType: 'crosshair'
};
let animationFrameId, transitionTimer;
let keys = { w:false, a:false, s:false, d:false, space:false, q:false, e:false, arrowUp:false, arrowDown:false, arrowLeft:false, arrowRight:false };
let mouse = { x: 0, y: 0, wx: 0, wy: 0, down: false };
let camera = { x: 0, y: 0 };
let screenShake = 0;

// GAME VARIABLES
let depthIndex = 0; 
let wave = 0; 
let waveSpawnScheduled = false; // Prevents spam-skip from queuing multiple spawns
let player = {};
let bullets=[], enemies=[], particles=[], xpOrbs=[], floatTexts=[], visuals=[];
let portal = { active: false, x: 0, y: 0, r: 80, angle: 0 };
let spawnTimer = 0;
let askedQuestions = []; 
let triviaAnswered = false;
let triviaLocked = false; // NEW: Prevent multiple answer clicks
let nextLevelIsModule = false; // When true, next level-up shows module pick (after wrong on module level)
let introKeysHeldWhenShown = {}; // Keys that were held when zone intro appeared; continue only on different key or click

// TIME & FPS
let lastTime = 0;
let gameTime = 0; // ms, for enemy contact cooldown
let fpsTimer = 0;
let frames = 0;
let aimMode = 'mouse'; // 'mouse' or 'keys'; switch only when user uses that input
let aimModeLockUntil = 0; // After overlay close, ignore mousemove for a moment so arrow-key aim isn't overridden

const glossary = {
    "accumulation": "Where snowfall adds more mass to a glacier than is lost; the upper zone where snow turns into firn and ice.",
    "ablation": "Processes that remove mass from a glacier (melting, sublimation, calving).",
    "equilibrium line": "The boundary altitude where annual accumulation equals annual ablation; above it the glacier gains mass, below it it loses mass.",
    "firn": "Old, compacted snow that has survived at least one melt season; an intermediate stage between snow and glacial ice.",
    "albedo": "How reflective a surface is. Higher albedo reflects more sunlight and reduces melting.",
    "basal friction": "Resistance between the glacier base and the bed. Lower basal friction can speed up glacier flow.",
    "meltwater": "Water produced by melting snow/ice. When it reaches the base, it can lubricate the bed and increase sliding.",
    "basal sliding": "Glacier motion caused by the ice sliding over the bed, often enhanced by meltwater.",
    "crevasses": "Deep cracks in glacier ice formed by stress when the ice stretches or moves over uneven terrain.",
    "tensile stress": "Pulling stress that stretches a material; in glaciers it commonly creates crevasses.",
    "plastic": "When ice deforms and flows rather than breaking; at depth, pressure makes ice behave more plastically.",
    "calving": "Breaking off of chunks of ice from a glacier terminus into water, forming icebergs.",
    "sublimation": "Ice turning directly into water vapor without melting.",
    "terminus": "The end (snout) of a glacier.",
    "moraines": "Ridges or piles of debris (sediment/rock) transported and deposited by glaciers.",
    "cirque": "A bowl-shaped hollow carved into a mountain by glacial erosion, often where glaciers form.",
    "aretes": "Sharp ridges formed when glaciers erode on both sides of a mountain ridge.",
    "horns": "Sharp, pyramid-like peaks formed when several cirques erode a mountain from multiple sides."
};

const glossaryTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);
const glossaryRegex = new RegExp(`\\b(${glossaryTerms.map(t => t.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')).join('|')})\\b`, 'gi');

const GENERAL_ARCHIVE_BLURB = `Glaciers grow or shrink based on <span style="color:#00f2fe">mass balance</span>: the difference between <span style="color:#00f2fe">accumulation</span> (snow gain) and <span style="color:#00f2fe">ablation</span> (ice loss). Flow speed is controlled by ice deformation and <span style="color:#00f2fe">basal sliding</span>, which can increase when <span style="color:#00f2fe">meltwater</span> reduces <span style="color:#00f2fe">basal friction</span>. Many surface clues (like the <span style="color:#00f2fe">equilibrium line</span>, crevasse patterns, and moraine deposits) reveal how a glacier is responding to climate and terrain.`;

function applyGlossaryToElement(el) {
    if (!el) return;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);

    nodes.forEach(node => {
        const text = node.nodeValue;
        if (!text) return;
        glossaryRegex.lastIndex = 0;
        if (!glossaryRegex.test(text)) return;
        glossaryRegex.lastIndex = 0;

        const frag = document.createDocumentFragment();
        let last = 0;
        text.replace(glossaryRegex, (match, _term, offset) => {
            if (offset > last) frag.appendChild(document.createTextNode(text.slice(last, offset)));
            const span = document.createElement('span');
            span.className = 'gloss-term';
            span.dataset.term = match.toLowerCase();
            span.textContent = match;
            frag.appendChild(span);
            last = offset + match.length;
        });
        if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
        node.parentNode.replaceChild(frag, node);
    });
}

const glossaryTooltip = document.getElementById('glossary-tooltip');
let glossaryTooltipActive = false;

function positionGlossaryTooltip(e) {
    if (!glossaryTooltipActive) return;
    const pad = 12;
    const margin = 16;
    let x = e.clientX + margin;
    let y = e.clientY + margin;
    const w = glossaryTooltip.offsetWidth;
    const h = glossaryTooltip.offsetHeight;
    if (x + w + pad > window.innerWidth) x = e.clientX - w - margin;
    if (y + h + pad > window.innerHeight) y = e.clientY - h - margin;
    glossaryTooltip.style.left = Math.max(pad, x) + 'px';
    glossaryTooltip.style.top = Math.max(pad, y) + 'px';
}

document.addEventListener('mouseover', (e) => {
    const termEl = e.target && e.target.closest ? e.target.closest('.gloss-term') : null;
    if (!termEl) return;
    const key = (termEl.dataset.term || '').toLowerCase();
    const def = glossary[key];
    if (!def) return;
    glossaryTooltip.innerHTML = `<div class="gt-title">${termEl.textContent}</div><div class="gt-body">${def}</div>`;
    glossaryTooltip.classList.add('show');
    glossaryTooltipActive = true;
    positionGlossaryTooltip(e);
});

document.addEventListener('mousemove', (e) => { positionGlossaryTooltip(e); });

document.addEventListener('mouseout', (e) => {
    const leavingTerm = e.target && e.target.closest ? e.target.closest('.gloss-term') : null;
    if (!leavingTerm) return;
    const to = e.relatedTarget;
    if (to && to.closest && to.closest('.gloss-term')) return;
    glossaryTooltip.classList.remove('show');
    glossaryTooltipActive = false;
});

/* --- DATA --- */
const abilitiesDB = [
    { id: 'shock', name: 'Shockwave', desc: 'Press SPACE to blast nearby enemies away.', color: '#00f2fe' },
    { id: 'mag', name: 'Gravity Well', desc: 'Press Q to pull XP orbs toward you.', color: '#fff' },
    { id: 'multi', name: 'Multi-Shot', desc: 'Press E to fire three shots at once.', color: '#ff9900' },
    { id: 'shield', name: 'Energy Shield', desc: 'Blocks one hit, then recharges.', color: '#00ffaa' }
];

// SIMPLE UPGRADES WITH CLEAR NAMES AND DESCRIPTIONS
const upgradesDB = [
    { n: "Faster Shooting", d: "Shoot 15% faster", apply: p=>{ p.fr=Math.max(3, p.fr*0.85); }, undo: p=>{ p.fr/=0.85; } },
    { n: "More Damage", d: "Bullets do 25% more damage", apply: p=>{ p.dmg*=1.25; }, undo: p=>{ p.dmg/=1.25; } },
    { n: "More Health", d: "Max health +30 and heal fully", apply: p=>{ p.maxHp+=30; p.hp=p.maxHp; }, undo: p=>{ p.maxHp-=30; if(p.hp>p.maxHp)p.hp=p.maxHp; } },
    { n: "Faster Movement", d: "Move 10% faster", apply: p=>{ p.spd*=1.1; }, undo: p=>{ p.spd/=1.1; } },
    { n: "Faster Bullets", d: "Bullets move 20% faster", apply: p=>{ p.bulletSpd*=1.2; }, undo: p=>{ p.bulletSpd/=1.2; } },
    // Conditional
    { req: 'shock', n: "Stronger Shockwave", d: "Shockwave damage +50", apply: p=>{ p.blastDmg+=50; }, undo: p=>{ p.blastDmg-=50; } },
    { req: 'shock', n: "Faster Shockwave", d: "Shockwave cooldown 20% faster", apply: p=>p.shockMax*=0.8, undo: p=>p.shockMax/=0.8 },
    { req: 'shock', n: "Bigger Shockwave", d: "Shockwave radius 25% bigger", apply: p=>p.shockRad*=1.25, undo: p=>p.shockRad/=1.25 },
    { req: 'mag', n: "Faster Gravity", d: "Gravity Well cooldown 20% faster", apply: p=>p.magMax*=0.8, undo: p=>p.magMax/=0.8 },
    { req: 'shield', n: "Faster Shield", d: "Shield recharges 20% faster", apply: p=>p.shieldMax*=0.8, undo: p=>p.shieldMax/=0.8 },
    { req: 'multi', n: "Longer Multi-Shot", d: "Multi-Shot lasts 1 second longer", apply: p=>p.multiDur+=60, undo: p=>p.multiDur-=60 },
    { req: 'multi', n: "Faster Multi-Shot", d: "Multi-Shot cooldown 20% faster", apply: p=>p.multiMax*=0.8, undo: p=>p.multiMax/=0.8 }
];

// IMPROVED TRIVIA QUESTIONS WITH BETTER FORMATTING
const triviaQuestions = [
    {
        id: 1,
        q: "A glacier begins flowing faster each year despite no increase in temperature. What is the most likely explanation?",
        a: ["Basal friction has decreased due to meltwater lubrication"],
        d: [
            "Ice crystals have grown larger from pressure",
            "Snow density in the accumulation zone increased",
            "Surface albedo has significantly increased"
        ],
        tags: ["general"]
    },
    {
        id: 2,
        q: "Two glaciers receive equal snowfall, but one grows while the other shrinks. What must be different between them?",
        a: ["Their total ablation rate differs significantly"],
        d: [
            "The color of their ice varies",
            "Their crevasse patterns are different",
            "The thickness of their firn layers"
        ],
        tags: ["general"]
    },
    {
        id: 3,
        q: "Which observation best indicates a glacier's accumulation zone has expanded?",
        a: ["The equilibrium line has moved downslope to a lower elevation"],
        d: [
            "Crevasses have widened near the terminus",
            "The glacier has begun calving icebergs",
            "Surface debris has thickened significantly"
        ],
        tags: ["accum"]
    },
    {
        id: 4,
        q: "After several consecutive colder summers, what change would appear FIRST in the accumulation zone?",
        a: ["Greater thickness of the firn layer"],
        d: [
            "Increased basal sliding velocity",
            "More extensive terminal moraine growth",
            "Deeper crevasse formation"
        ],
        tags: ["accum"]
    },
    {
        id: 5,
        q: "A glacier's equilibrium line rises for multiple consecutive years. What long-term trend should follow?",
        a: ["Net mass loss increases as the ablation zone expands"],
        d: [
            "Basal temperatures drop significantly",
            "Ice flow velocity reaches its maximum",
            "Moraine sediment becomes better sorted"
        ],
        tags: ["eq"]
    },
    {
        id: 6,
        q: "What condition could keep a glacier stable despite unusually warm summers?",
        a: ["Exceptionally high winter snowfall"],
        d: [
            "Thick surface debris insulating the ice",
            "Exceptionally low ice density",
            "Very steep valley walls"
        ],
        tags: ["eq"]
    },
    {
        id: 7,
        q: "A glacier enters a significantly steeper valley section. What surface change is most likely?",
        a: ["Increased crevasse formation due to tensile stress"],
        d: [
            "Ice becomes more transparent and blue",
            "Overall flow velocity decreases",
            "Firn compacts into ice more rapidly"
        ],
        tags: ["crev"]
    },
    {
        id: 8,
        q: "Why do crevasses rarely extend more than 50 meters deep into glacier ice?",
        a: ["Ice flows plastically under pressure at depth"],
        d: [
            "Meltwater refreezes and seals the cracks",
            "Temperature increases with depth, making ice ductile",
            "Rock debris naturally fills the fractures"
        ],
        tags: ["crev"]
    },
    {
        id: 9,
        q: "Which landscape feature provides the STRONGEST evidence of long-term glacial erosion?",
        a: ["A classic U-shaped valley with steep sides"],
        d: [
            "A V-shaped river valley",
            "A braided river system",
            "A broad floodplain"
        ],
        tags: ["land"]
    },
    {
        id: 10,
        q: "Two cirques continue eroding backward toward each other. What landform typically remains between them?",
        a: ["A sharp, narrow ridge called an arête"],
        d: [
            "A flat-bottomed basin",
            "A debris fan formation",
            "A meltwater channel network"
        ],
        tags: ["land"]
    },
    {
        id: 11,
        q: "A glacier loses mass despite air temperatures staying below freezing. Which process explains this?",
        a: ["Sublimation - direct ice-to-vapor transition"],
        d: [
            "Surface melting from solar radiation",
            "Basal freezing adding ice at the bottom",
            "Firn compaction reducing volume"
        ],
        tags: ["abl"]
    },
    {
        id: 12,
        q: "Which factor most strongly increases glacier ablation rates?",
        a: ["Longer duration of the melt season"],
        d: [
            "Higher snow albedo (reflectivity)",
            "Steeper slopes in accumulation zone",
            "Lower overall ice density"
        ],
        tags: ["abl"]
    },
    {
        id: 13,
        q: "Glacial debris contains unsorted mixture of boulders and clay in same layer. What does this indicate?",
        a: ["Direct transport by ice without water sorting"],
        d: [
            "Sorting by meltwater streams",
            "Wind deposition and sorting",
            "Multiple freeze-thaw cycles"
        ],
        tags: ["mor"]
    },
    {
        id: 14,
        q: "A retreating glacier leaves a large ridge of debris parallel to its former flow. What does this ridge mark?",
        a: ["A former stable terminus position (terminal moraine)"],
        d: [
            "The equilibrium line position",
            "The zone of maximum flow velocity",
            "The accumulation zone maximum"
        ],
        tags: ["mor"]
    }
];
 
/* --- NAVIGATION --- */
function hideAll() { Object.values(screens).forEach(s => s.classList.add('hidden')); }
function goBackFromArchive() {
    if(previousState === 'MENU') {
        hideAll();
        screens.start.classList.remove('hidden');
        gameState = "MENU";
        renderBackground();
    } else if(previousState === 'PAUSE') {
        screens.learn.classList.add('hidden');
        screens.pause.classList.remove('hidden');
        gameState = "PAUSE";
        updatePauseStats();
    } else if(previousState === 'PLAY') {
        hideAll();
        screens.hud.classList.remove('hidden');
        gameState = "PLAY";
    } else {
        // Default to main menu if state is unclear
        hideAll();
        screens.start.classList.remove('hidden');
        gameState = "MENU";
        renderBackground();
    }
    updateCanvasCursor();
}

function goHome() { 
    if(transitionTimer) clearTimeout(transitionTimer);
    gameState="MENU"; hideAll(); screens.start.classList.remove('hidden'); 
    updateCanvasCursor();
    renderBackground(); 
}

function showLearn() {
    previousState = gameState; // Remember where we came from
    if(previousState === 'PAUSE') {
        screens.pause.classList.add('hidden');
        screens.learn.classList.remove('hidden');
    } else {
        hideAll();
        screens.learn.classList.remove('hidden');
    }
    renderArchive();
}

function renderArchive() {
    const container = document.getElementById('archive-container');
    if (!container) return;

    const zoneTags = ['accum', 'eq', 'crev', 'land', 'abl', 'mor'];

    const buildTakeawaysHtml = (tag) => {
        const qs = triviaQuestions.filter(q => q.tags && q.tags.includes(tag));
        if (qs.length === 0) return "";
        const unique = [...new Set(qs.map(q => (q.a && q.a[0]) ? q.a[0] : "").filter(Boolean))];
        if (unique.length === 0) return "";
        return `<div style="margin-top:14px; color:#00ffaa; font-weight:900; letter-spacing:1px;">KEY ANSWERS</div><ul>${unique.map(a => `<li>${a}</li>`).join('')}</ul>`;
    };

    const sections = [];
    for (let i = 0; i < DEPTH_NAMES.length; i++) {
        const tag = zoneTags[i];
        const zoneTitle = `ZONE ${i + 1}: ${DEPTH_NAMES[i]}`;
        const desc = ZONE_DESCRIPTIONS[i] || "";
        const takeaways = tag ? buildTakeawaysHtml(tag) : "";
        sections.push(`
            <div class="archive-section">
                <div class="archive-section-title">${zoneTitle}</div>
                <div class="archive-section-body">${desc}${takeaways}</div>
            </div>
        `);
    }

    const generalTakeaways = buildTakeawaysHtml('general');
    sections.push(`
        <div class="archive-section">
            <div class="archive-section-title">GENERAL KNOWLEDGE</div>
            <div class="archive-section-body">${GENERAL_ARCHIVE_BLURB}${generalTakeaways}</div>
        </div>
    `);

    container.innerHTML = sections.join('');
    applyGlossaryToElement(container);
}

function switchArchiveTab(tabName) {
    renderArchive();
}

function openSettings(fromState) {
    previousState = fromState === 'MENU' ? 'MENU' : gameState;
    if(gameState === 'PLAY') gameState = 'PAUSE'; 
    hideAll();
    screens.settings.classList.remove('hidden');
    
    // Update UI to reflect current settings
    updateMouseTypeUI();
    if (typeof updateZoomPreview === 'function') updateZoomPreview(gameSettings.zoomLevel);
    document.getElementById('btn-bloom').innerText = gameSettings.bloom ? "EFFECTS: HIGH" : "EFFECTS: LOW";
}

function closeSettings() {
    hideAll();
    if(previousState === 'MENU') {
        screens.start.classList.remove('hidden');
        gameState = "MENU";
    } else {
        screens.pause.classList.remove('hidden');
        screens.hud.classList.remove('hidden');
        gameState = "PAUSE";
    }
}

function applyCanvasResolution() {
    canvas.width = 1920;
    canvas.height = 1080;
    if (gameState === "MENU") renderBackground();
}

function toggleBloom() {
    gameSettings.bloom = !gameSettings.bloom;
    document.getElementById('btn-bloom').innerText = gameSettings.bloom ? "EFFECTS: HIGH" : "EFFECTS: LOW";
}

function toggleFps() {
    gameSettings.fps = !gameSettings.fps;
    document.getElementById('btn-fps').innerText = gameSettings.fps ? "FPS: ON" : "FPS: OFF";
    document.getElementById('fps-counter').style.display = gameSettings.fps ? 'block' : 'none';
}
 
function changeMouseType(type) {
    gameSettings.mouseType = type;
    updateMouseTypeUI();
    updateCanvasCursor();
}

function updateMouseTypeUI() {
    document.querySelectorAll('.mouse-option').forEach(option => {
        option.classList.remove('active');
    });
    document.querySelector(`[onclick="changeMouseType('${gameSettings.mouseType}')"]`).classList.add('active');
}

function updateCanvasCursor() {
    switch(gameSettings.mouseType) {
        case 'crosshair':
            canvas.style.cursor = "crosshair";
            break;
        case 'pointer':
            canvas.style.cursor = "pointer";
            break;
        case 'circle':
            canvas.style.cursor = "none";
            break;
    }
}

function startGame() { 
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    if(transitionTimer) clearTimeout(transitionTimer);
    hideAll(); screens.hud.classList.remove('hidden'); 
    updateCanvasCursor();
    
    depthIndex = 0;
    gameTime = 0;
    aimMode = 'mouse';
    nextLevelIsModule = false;
    resetPlayer();
    showZoneIntro(); // Show intro instead of directly starting
    
    lastTime = performance.now();
    loop(lastTime); 
}

function showZoneIntro() {
    gameState = "INTRO";
    screens.zoneIntro.classList.remove('hidden');
    
    // Pre-simulate snow during the intro for Zone of Accumulation
    if (depthIndex === 0) {
        // Clear existing snow
        SNOW_PARTICLES.length = 0;
        
        // Pre-populate with snow throughout the screen
        for (let i = 0; i < 100; i++) {
            createSnowfallParticle(Math.random() * ROOM_HEIGHT, true);
        }
        
        // Simulate a few seconds of snowfall
        const simTime = 3; // seconds
        const steps = 60 * simTime; // 60fps * seconds
        const dt = 1000/60; // 60fps in ms
        
        for (let i = 0; i < steps; i++) {
            updateSnowParticles(dt);
        }
    }
    
    // Remember which keys were held so we only continue on a *different* key or after release
    introKeysHeldWhenShown = {
        w: keys.w, a: keys.a, s: keys.s, d: keys.d, space: keys.space,
        arrowUp: keys.arrowUp, arrowDown: keys.arrowDown, arrowLeft: keys.arrowLeft, arrowRight: keys.arrowRight
    };
    
    document.getElementById('zone-title').textContent = DEPTH_NAMES[depthIndex];
    document.getElementById('zone-description').innerHTML = buildZoneBrief(depthIndex);
    applyGlossaryToElement(document.getElementById('zone-description'));
    document.getElementById('zone-continue').textContent = "Press a key or click to continue...";
    
    document.addEventListener('keydown', handleIntroContinue);
    canvas.addEventListener('click', handleIntroContinue);
}

function buildZoneBrief(idx) {
    const zoneTags = ['accum', 'eq', 'crev', 'land', 'abl', 'mor'];
    const tag = zoneTags[idx];

    const pool = triviaQuestions.filter(q => q.tags && (q.tags.includes('general') || (tag && q.tags.includes(tag))));
    const answers = [...new Set(pool.map(q => (q.a && q.a[0]) ? q.a[0] : '').filter(Boolean))];

    const toSentence = (s) => {
        const t = (s || '').trim();
        if (!t) return '';
        return /[.!?]$/.test(t) ? t : (t + '.');
    };

    const base = (ZONE_DESCRIPTIONS[idx] || '').trim();
    const basePara = base ? `<p>${base}</p>` : '';

    if (answers.length === 0) return basePara;

    const chunks = [];
    const targetParas = answers.length > 12 ? 3 : (answers.length > 6 ? 2 : 1);
    const chunkSize = Math.ceil(answers.length / targetParas);
    for (let i = 0; i < answers.length; i += chunkSize) chunks.push(answers.slice(i, i + chunkSize));

    const factParas = chunks.slice(0, 3).map((group, i) => {
        const label = (i === 0) ? 'Key ideas for this zone:' : (i === 1) ? 'More to remember:' : 'Final notes:';
        const body = group.map(toSentence).join(' ');
        return `<p><span style="color:#00ffaa; font-weight:900; letter-spacing:1px;">${label}</span> ${body}</p>`;
    }).join('');

    return basePara + factParas;
}

function handleIntroContinue(e) {
    if (gameState !== "INTRO") return;
    
    // Click always counts as "new" action - continue
    if (e.type === 'click') {
        document.removeEventListener('keydown', handleIntroContinue);
        canvas.removeEventListener('click', handleIntroContinue);
        screens.zoneIntro.classList.add('hidden');
        startDepth();
        return;
    }
    
    // Keydown: only continue if this key was NOT already held when the intro appeared
    // (so they must press a different key, or release and press again)
    if (e.type === 'keydown') {
        if (e.code === 'Space') e.preventDefault();
        const codeToKey = { 'KeyW':'w','KeyA':'a','KeyS':'s','KeyD':'d','Space':'space','ArrowUp':'arrowUp','ArrowDown':'arrowDown','ArrowLeft':'arrowLeft','ArrowRight':'arrowRight' };
        const keyName = codeToKey[e.code];
        if (keyName && introKeysHeldWhenShown[keyName]) return; // still the same key held - ignore until they release or press another key
    }
    
    document.removeEventListener('keydown', handleIntroContinue);
    canvas.removeEventListener('click', handleIntroContinue);
    screens.zoneIntro.classList.add('hidden');
    startDepth();
}

function resetPlayer() {
    player = {
        x: ROOM_WIDTH/2, y: ROOM_HEIGHT/2,
        hp: 100, maxHp: 100, xp: 0, req: 50, lvl: 1,
        spd: 7, dmg: 30, fr: 18, cd: 0, bulletSpd: 16,
        shotCount: 0, blastDmg: 200, 
        upgradeHistory: [],
        hasShock: false, shockMax: 600, shockTimer: 600, shockRad: 450, 
        hasMag: false, magMax: 1000, magTimer: 1000, magDur: 150, magActive: 0,
        hasMulti: false, multiMax: 900, multiTimer: 900, multiDur: 120, multiActive: 0,
        hasShield: false, shieldMax: 800, shieldTimer: 800, shieldUp: false
    };
    askedQuestions = [];
    updateHUD(); updateSkillUI();
    // Update Dev Console Values
    document.getElementById('dev-dmg').value = player.dmg;
    document.getElementById('dev-fr').value = player.fr;
    document.getElementById('dev-spd').value = player.spd;
    document.getElementById('dev-bspd').value = player.bulletSpd;
}

function togglePause() {
    if(gameState === "PLAY") {
        gameState = "PAUSE";
        screens.pause.classList.remove('hidden');
        updatePauseStats();
    } else if(gameState === "PAUSE") {
        gameState = "PLAY";
        screens.pause.classList.add('hidden');
        lastTime = performance.now(); // Reset time to avoid jump
    }
}

function updatePauseStats() {
    document.getElementById('st-dmg').innerText = Math.floor(player.dmg);
    document.getElementById('st-fr').innerText = (60/player.fr).toFixed(1) + "/s";
    document.getElementById('st-spd').innerText = player.spd.toFixed(1);
    document.getElementById('st-hp').innerText = Math.floor(player.maxHp);
    
    let m = document.getElementById('st-mods');
    m.innerHTML = "";
    if(!player.hasShock && !player.hasMag && !player.hasShield && !player.hasMulti) m.innerHTML = "<span style='color:#666'>No Modules Installed</span>";
    if(player.hasShock) m.innerHTML += "<div class='stat-row' style='color:#00f2fe'>Shockwave</div>";
    if(player.hasMag) m.innerHTML += "<div class='stat-row' style='color:#fff'>Gravity Well</div>";
    if(player.hasMulti) m.innerHTML += "<div class='stat-row' style='color:#ff9900'>Multi-Shot</div>";
    if(player.hasShield) m.innerHTML += "<div class='stat-row' style='color:#00ffaa'>Energy Shield</div>";
}

/* --- GAME LOGIC --- */
function startDepth() {
    // Show Transition
    gameState = "TRANSITION";
    portal.active = false; // Reset portal
    screens.depth.classList.remove('hidden');
    document.getElementById('depth-title').innerText = DEPTH_NAMES[depthIndex];
    document.getElementById('depth-sub').innerText = `DEPTH ${depthIndex + 1}`;
    
    transitionTimer = setTimeout(() => {
        screens.depth.classList.add('hidden');
        gameState = "PLAY";
        lastTime = performance.now(); // Reset Delta
        wave = 0;
        bullets = []; enemies = []; particles = []; visuals = []; xpOrbs = [];
        player.x = ROOM_WIDTH/2; player.y = ROOM_HEIGHT/2;
        document.getElementById('level-tag').innerText = DEPTH_NAMES[depthIndex];
        spawnNextWave();
    }, 5000);
}

function spawnNextWave() {
    // GUARD CLAUSE: Don't spawn if portal is active or already at max wave
    if(portal.active) return;
    if(wave >= WAVES_PER_DEPTH) return;
    
    waveSpawnScheduled = false;
    wave++;
    document.getElementById('wave-tag').innerText = `WAVE ${wave}/${WAVES_PER_DEPTH}`;
    addFloat(`WAVE ${wave}`, player.x, player.y - 150, "#ff9900");

    // MODERATE SPAM LOGIC: Original formula * 1.5 (50% Increase)
    let rawCount = 3 + (depthIndex * 1.8) + Math.floor(wave * 0.6);
    const count = Math.floor(rawCount * 1.5);
    
    for(let i=0; i<count; i++) {
        // STRICTER SHAPE LOGIC:
        let maxSides = 4 + depthIndex; 
        let minSides = 3;
        let sides = minSides + Math.floor(Math.random() * (maxSides - minSides + 1));

        // HP and Speed Tweaks
        let hp = (35 + (depthIndex*10) + (wave*4)) * (1+(sides-3)*0.4);
        let spd = Math.max(1.5, 5 - (sides*0.5) + (depthIndex*0.1)); // Original speed formula
        
        let ex, ey, dist;
        do {
            ex = Math.random()*ROOM_WIDTH;
            ey = Math.random()*ROOM_HEIGHT;
            dist = Math.sqrt((ex-player.x)**2 + (ey-player.y)**2);
        } while(dist < 700); 

        const colors = ['#ff0055','#ff9900','#ffe600','#33ff00','#00ffff','#0066ff','#9900ff'];
        enemies.push({ 
            id: Math.random(),
            x:ex, y:ey, hp:hp, maxHp:hp, sides:sides, size:20+(sides*4), spd:spd, 
            color:colors[(sides-3)%7], angle:0, spin:(Math.random()-0.5)*0.15,
            type: 'normal',
            xpValue: (sides * sides) + (depthIndex * 20) // XP based on enemy stats
        });
        visuals.push({type:'spawn', x:ex, y:ey, r:60, op:1});
    }

    // SPAWN KAMIKAZES (Starting from Depth 2 or late waves of Depth 1)
    if(depthIndex >= 1) {
        let kamiCount = Math.floor(wave / 3) + (depthIndex - 1);
        if(kamiCount > 0) {
            for(let k=0; k<kamiCount; k++) {
                let ex, ey, dist;
                do {
                    ex = Math.random()*ROOM_WIDTH;
                    ey = Math.random()*ROOM_HEIGHT;
                    dist = Math.sqrt((ex-player.x)**2 + (ey-player.y)**2);
                } while(dist < 900); 

                enemies.push({ 
                    id: Math.random(),
                    x:ex, y:ey, hp: 1, maxHp:1, sides:3, size:25, spd:9, // Fast
                    color: '#ff0000', angle:0, spin:0.3,
                    type: 'kamikaze',
                    xpValue: 50 + (depthIndex * 10) // Kamikazes give more XP
                });
                visuals.push({type:'spawn', x:ex, y:ey, r:60, op:1});
                addFloat("WARNING", ex, ey, "#ff0000");
            }
        }
    }
}

function checkWaveClear() {
    if(enemies.length === 0 && gameState === "PLAY") {
        if(wave >= WAVES_PER_DEPTH) {
            // PORTAL SPAWNS CENTER
            if(!portal.active) {
                portal.active = true;
                portal.x = ROOM_WIDTH / 2;
                portal.y = ROOM_HEIGHT / 2;
                addFloat("PORTAL OPEN", portal.x, portal.y - 120, "#00ffaa");
            }
        } else if(!waveSpawnScheduled) {
            waveSpawnScheduled = true;
            setTimeout(spawnNextWave, 1000); 
        }
    }
}

/* --- TRIVIA & LEVEL UP --- */
function checkLevelUp() {
    if(player.xp >= player.req) {
        player.xp = 0; player.req = Math.floor(player.req * 1.35);
        player.lvl++;
        updateHUD();
        startTrivia();
    }
}

function startTrivia() {
    triviaAnswered = false;
    triviaLocked = false; // Reset lock

    // If they got the previous question wrong on a module level, this level-up is the module
    if(nextLevelIsModule) {
        nextLevelIsModule = false;
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });
        if(unacquired.length > 0) {
            triggerUnlock(unacquired);
            return;
        }
    }

    gameState = "TRIVIA";
    screens.trivia.classList.remove('hidden');
    document.getElementById('t-status').innerText = "";
    
    // Pick Question logic
    let tag = "";
    if(depthIndex===0) tag="accum"; else if(depthIndex===1) tag="eq"; else if(depthIndex===2) tag="crev";
    else if(depthIndex===3) tag="land"; else if(depthIndex===4) tag="abl"; else if(depthIndex===5) tag="mor";
    
    // Filter available questions not asked yet
    let pool = triviaQuestions.filter(q => !askedQuestions.includes(q.id) && (q.tags.includes("general") || q.tags.includes(tag)));
    // If ran out, reset pool for this tag
    if(pool.length === 0) {
        pool = triviaQuestions.filter(q => q.tags.includes("general") || q.tags.includes(tag));
    }
    
    let q = pool[Math.floor(Math.random()*pool.length)];
    askedQuestions.push(q.id);

    // Format question with line breaks for readability
    let formattedQ = q.q;
    // Add line breaks after commas or periods when question is long
    if (q.q.length > 80) {
        formattedQ = q.q.replace(/([,.])\s+(?=\w)/g, '$1<br>');
    }
    
    document.getElementById('t-ques').innerHTML = formattedQ;
    applyGlossaryToElement(document.getElementById('t-ques'));

    // Answers
    let correct = q.a[0];
    let opts = [correct, ...q.d];
    opts.sort(() => Math.random() - 0.5);

    const box = document.getElementById('t-opts'); 
    box.innerHTML = "";
    
    opts.forEach(o => {
        let btn = document.createElement('button');
        btn.className = "t-btn";
        btn.innerHTML = `<span class="t-btn-text">${o}</span>`;
        applyGlossaryToElement(btn.querySelector('.t-btn-text'));
        btn.onclick = () => {
            if (!triviaLocked) {
                triviaLocked = true; // Lock answers
                checkAnswer(o === correct, btn);
            }
        };
        box.appendChild(btn);
    });
}

function checkAnswer(isCorrect, clickedBtn) {
    triviaAnswered = true;
    
    // Disable all answer buttons
    document.querySelectorAll('.t-btn').forEach(btn => {
        btn.classList.add('disabled');
        btn.style.pointerEvents = 'none';
    });
    
    if(isCorrect) {
        document.getElementById('t-status').innerText = "CORRECT";
        document.getElementById('t-status').style.color = "#00ffaa";
        clickedBtn.style.backgroundColor = "#00ffaa";
        clickedBtn.style.color = "#000";
        clickedBtn.style.borderColor = "#00ffaa";
        
        setTimeout(() => {
            screens.trivia.classList.add('hidden');
            
            // Check for Module Unlock every 4 levels
            const unacquired = abilitiesDB.filter(a => {
                if(a.id==='shock' && player.hasShock) return false;
                if(a.id==='mag' && player.hasMag) return false;
                if(a.id==='multi' && player.hasMulti) return false;
                if(a.id==='shield' && player.hasShield) return false;
                return true;
            });

            if(player.lvl % 4 === 0 && unacquired.length > 0) triggerUnlock(unacquired);
            else triggerUpgrade();
            
        }, 800);
    } else {
        document.getElementById('t-status').innerText = "INCORRECT";
        document.getElementById('t-status').style.color = "#ff2a6d";
        clickedBtn.style.backgroundColor = "#ff2a6d";
        clickedBtn.style.color = "#000";
        clickedBtn.style.borderColor = "#ff2a6d";
        
        shake(10);
        // Wrong on a level that would have been module (every 4 levels): next level-up = module
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });
        if(player.lvl % 4 === 0 && unacquired.length > 0) nextLevelIsModule = true;

        setTimeout(() => {
            screens.trivia.classList.add('hidden');
            aimModeLockUntil = Date.now() + 250; // Preserve arrow-key aim when exiting trivia
            gameState = "PLAY";
            lastTime = performance.now(); // Reset time to avoid physics jump
        }, 1500);
    }
}

function triggerUnlock(availableAbs) {
    gameState="UPGRADE"; screens.upgrade.classList.remove('hidden');
    document.getElementById('up-header').innerText = "NEW MODULE";
    document.getElementById('up-header').style.color = "#ff00de";
    const con = document.getElementById('up-container'); con.innerHTML="";
    availableAbs.forEach(a => {
        const div = document.createElement('div'); div.className='upgrade-btn unlock-btn';
        div.innerHTML=`<div class="u-tag">NEW ABILITY</div><div class="u-title">${a.name}</div><div class="u-desc">${a.desc}</div>`;
        div.onclick = () => {
            if(a.id==='shock') player.hasShock=true;
            if(a.id==='mag') player.hasMag=true;
            if(a.id==='multi') player.hasMulti=true;
            if(a.id==='shield') { player.hasShield=true; player.shieldUp=true; }
            finishLevelUp(null);
        };
        con.appendChild(div);
    });
}

function triggerUpgrade() {
    gameState="UPGRADE"; screens.upgrade.classList.remove('hidden');
    document.getElementById('up-header').innerText = "LEVEL UP";
    document.getElementById('up-header').style.color = "#fff";
    const con = document.getElementById('up-container'); con.innerHTML="";
    
    // 1. Force More Health upgrade
    const healthUpgrade = upgradesDB.find(u => u.n === "More Health");

    // 2. Get pool of others
    let pool = upgradesDB.filter(u => {
        if(u.n === "More Health") return false; 
        if(u.req === 'shock' && !player.hasShock) return false;
        if(u.req === 'mag' && !player.hasMag) return false;
        if(u.req === 'multi' && !player.hasMulti) return false;
        if(u.req === 'shield' && !player.hasShield) return false;
        return true;
    });

    // 3. Select 3 randoms + Health upgrade
    let selected = pool.sort(()=>Math.random()-0.5).slice(0,3);
    selected.push(healthUpgrade);
    
    // 4. Shuffle again for display
    selected.sort(()=>Math.random()-0.5);

    selected.forEach(u => {
        const div = document.createElement('div'); div.className='upgrade-btn';
        div.innerHTML=`<div class="u-tag">UPGRADE</div><div class="u-title">${u.n}</div><div class="u-desc">${u.d}</div>`;
        div.onclick = () => { u.apply(player); finishLevelUp(u); };
        con.appendChild(div);
    });
}

function finishLevelUp(upObj) { 
    if(upObj) player.upgradeHistory.push(upObj); 
    aimModeLockUntil = Date.now() + 250; // Preserve arrow-key aim when exiting upgrade
    updateHUD(); updateSkillUI(); screens.upgrade.classList.add('hidden'); gameState="PLAY"; 
    lastTime = performance.now(); // Reset time
    // Sync Dev Console
    document.getElementById('dev-dmg').value = player.dmg;
    document.getElementById('dev-fr').value = player.fr;
    document.getElementById('dev-spd').value = player.spd;
}

/* --- UPDATES --- */
function updateHUD() {
    document.getElementById('hp-fill').style.width = Math.max(0, (player.hp/player.maxHp*100)) + "%";
    document.getElementById('xp-fill').style.width = (player.xp/player.req*100) + "%";
    document.getElementById('lvl-txt').innerText = player.lvl;
}

function updateSkillUI() {
    const u = (id, has, timer, max, active) => {
        const box = document.getElementById('skill-'+id);
        const cd = document.getElementById('cd-'+id);
        if(has) {
            box.style.display="flex";
            let pct = 1 - (timer/max);
            if(active > 0) pct = 0; 
            cd.style.height = (pct*100)+"%";
            const ready = (timer >= max && active <= 0);
            if(ready) box.classList.add('ready'); else box.classList.remove('ready');
            if(!ready) box.classList.add('cooling'); else box.classList.remove('cooling');
        } else box.style.display="none";
    };
    u('shock', player.hasShock, player.shockTimer, player.shockMax, 0);
    u('mag', player.hasMag, player.magTimer, player.magMax, player.magActive);
    u('multi', player.hasMulti, player.multiTimer, player.multiMax, player.multiActive);
    
    const shBox = document.getElementById('skill-shield');
    if(player.hasShield) {
        shBox.style.display="flex";
        if(player.shieldUp) { shBox.classList.add('ready'); shBox.classList.remove('cooling'); document.getElementById('cd-shield').style.height="0%"; }
        else { shBox.classList.remove('ready'); shBox.classList.add('cooling'); document.getElementById('cd-shield').style.height=(player.shieldTimer/player.shieldMax*100)+"%"; }
    } else shBox.style.display="none";
}

function shake(amt) { screenShake=amt; }
function addFloat(t,x,y,c) { if(floatTexts.length>20)floatTexts.shift(); floatTexts.push({t,x,y,c,l:60}); }
function getDistSq(x1, y1, x2, y2) { return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2); }

let viewBounds = null; // Set each frame in drawRoom; avoids repeated camera/canvas reads
function isOnScreen(obj) {
    if (!viewBounds) return true;
    return (obj.x >= viewBounds.left && obj.x <= viewBounds.right &&
            obj.y >= viewBounds.top && obj.y <= viewBounds.bottom);
}

/* --- MAIN LOOP --- */
function loop(timestamp) {
    const isIdle = (gameState === "MENU" || gameState === "WIN" || gameState === "INTRO");
    if (!isIdle) animationFrameId = requestAnimationFrame(loop);
    else animationFrameId = setTimeout(() => requestAnimationFrame(loop), 100);
    
    // FPS Calculation
    if(!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Normalization: 1.0 at 60 FPS
    let dt = Math.min(deltaTime / 16.666, 4); 

    fpsTimer += deltaTime;
    frames++;
    if(fpsTimer >= 500) {
        document.getElementById('fps-counter').innerText = "FPS: " + Math.round((frames * 1000) / fpsTimer);
        frames = 0;
        fpsTimer = 0;
    }

    // DEV TOOL HOOK: UPDATE LOOP
    if(window.devUpdate) window.devUpdate();
    
    if(gameState === "MENU" || gameState === "WIN" || gameState === "INTRO") { 
        renderBackground(); 
        if (gameSettings.mouseType === 'circle' && (gameState === "INTRO" || gameState === "MENU")) {
            drawCustomCursor();
        }
        return; 
    }
    if(gameState !== "PLAY") return; // PAUSE EVERYTHING ELSE
    
    update(dt);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); applyCamera(); drawRoom(); ctx.restore();
    
    // Draw custom cursor if needed
    if (gameSettings.mouseType === 'circle') {
        drawCustomCursor();
    }
}

function drawCustomCursor() {
    ctx.save();
    ctx.translate(mouse.x, mouse.y);
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, TAU);
    ctx.stroke();
    ctx.restore();
}

function applyCamera() {
    let targetX = player.x - canvas.width/2;
    let targetY = player.y - canvas.height/2;
    let sx=(Math.random()-0.5)*screenShake, sy=(Math.random()-0.5)*screenShake;
    if(screenShake>0) screenShake*=0.9;
    camera.x += (targetX - camera.x)*0.1;
    camera.y += (targetY - camera.y)*0.1;
    
    // Apply zoom scaling
    ctx.translate(-camera.x+sx, -camera.y+sy);
}

function createSnowfallParticle(initialY = -20, randomY = false) {
    if (SNOW_PARTICLES.length >= MAX_PARTICLES) return;
    
    // Calculate spawn area within room bounds
    const x = 20 + Math.random() * (ROOM_WIDTH - 40);
    // If randomY is true, spawn anywhere from top to bottom of screen
    const y = randomY ? Math.random() * ROOM_HEIGHT : (initialY || -20);
    
    SNOW_PARTICLES.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5, // Slower side-to-side drift
        vy: Math.random() * 0.8 + 0.5,   // Slower downward speed
        c: 'rgba(255, 255, 255, 0.7)',   // Slightly transparent
        s: Math.random() * 2 + 1,        // Varying size
        // No lifetime - snow stays until it hits bottom or goes off screen
    });
}

function updateSnowParticles(dt) {
    // Always update snow particles, even when not in Zone 1
    for (let i = SNOW_PARTICLES.length - 1; i >= 0; i--) {
        const p = SNOW_PARTICLES[i];
        
        // Update position
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        
        // Bounce off walls
        if (p.x < 20) { p.x = 20; p.vx *= -0.5; }
        if (p.x > ROOM_WIDTH - 20) { p.x = ROOM_WIDTH - 20; p.vx *= -0.5; }
        
        // Remove if below bottom of screen
        if (p.y > ROOM_HEIGHT) {
            SNOW_PARTICLES.splice(i, 1);
        }
    }
    
    // Add new snow particles if in Zone 1
    if (depthIndex === 0) {
        // Create a more consistent flow of snow (2-3 particles per frame)
        const snowPerFrame = 2 + Math.random();
        for (let i = 0; i < snowPerFrame; i++) {
            if (Math.random() < 0.5) { // 50% chance to spawn a new flake each frame
                createSnowfallParticle();
            }
        }
    }
}

function update(dt) {
    // Always update snow particles
    updateSnowParticles(dt);
    
    mouse.wx = mouse.x + camera.x; mouse.wy = mouse.y + camera.y;

    // Movement (Scaled by DT)
    if(keys.w) player.y-=player.spd * dt;
    if(keys.s) player.y+=player.spd * dt;
    if(keys.a) player.x-=player.spd * dt;
    if(keys.d) player.x+=player.spd * dt;
    if(player.x < 30) player.x = 30; if(player.x > ROOM_WIDTH-30) player.x = ROOM_WIDTH-30;
    if(player.y < 30) player.y = 30; if(player.y > ROOM_HEIGHT-30) player.y = ROOM_HEIGHT-30;

    // PORTAL INTERACTION
    if(portal.active) {
        portal.angle += 0.02 * dt;
        if(getDistSq(player.x, player.y, portal.x, portal.y) < (portal.r/2 + 30)**2) {
            // Enter portal
            portal.active = false;
            depthIndex++;
            if(depthIndex >= DEPTH_NAMES.length) {
                // WIN CONDITION
                gameState = "WIN";
                hideAll();
                screens.win.classList.remove('hidden');
            } else {
                showZoneIntro(); // Always show intro for next zone
            }
            return;
        }
    }

    // Skills
    if(player.hasShock) {
        if(player.shockTimer < player.shockMax) player.shockTimer += dt;
        if(keys.space && player.shockTimer >= player.shockMax) {
            player.shockTimer = 0; shake(30);
            visuals.push({type:'shock', x:player.x, y:player.y, r:0, maxR:player.shockRad, op:1});
            const shockRad = player.shockRad;
            const rSq = shockRad * shockRad;
            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                if (Math.abs(e.x - player.x) > shockRad || Math.abs(e.y - player.y) > shockRad) continue;
                if(getDistSq(e.x, e.y, player.x, player.y) < rSq) {
                    e.hp -= player.blastDmg;
                    addFloat(Math.floor(player.blastDmg), e.x, e.y, "#00f2fe"); 
                    let a=Math.atan2(e.y-player.y, e.x-player.x);
                    // Pushback scaled by DT isn't necessary for impulse, but consistent force
                    e.x+=Math.cos(a)*350; e.y+=Math.sin(a)*350; 
                    
                    // Kill check immediately
                    if(e.hp <= 0) {
                        killEnemy(e, i); // XP Drop restored
                        checkWaveClear();
                    }
                }
            }
        }
    }
    if(player.hasMag) {
        if(player.magActive > 0) player.magActive -= dt;
        else if(player.magTimer < player.magMax) player.magTimer += dt;
        if(keys.q && player.magTimer >= player.magMax && player.magActive <= 0) {
            player.magTimer = 0; player.magActive = player.magDur; 
            addFloat("MAGNET", player.x, player.y-50, "#fff");
        }
    }
    if(player.hasMulti) {
        if(player.multiActive > 0) player.multiActive -= dt;
        else if(player.multiTimer < player.multiMax) player.multiTimer += dt;
        if(keys.e && player.multiTimer >= player.multiMax && player.multiActive <= 0) {
            player.multiTimer = 0; player.multiActive = player.multiDur;
            addFloat("MULTI-SHOT", player.x, player.y-50, "#ff9900");
        }
    }
    if(player.hasShield && !player.shieldUp) {
        player.shieldTimer -= dt;
        if(player.shieldTimer<=0) { player.shieldUp=true; player.shieldTimer=player.shieldMax; addFloat("SHIELD RECHARGED", player.x, player.y-50, "#00ffaa"); }
    }
    updateSkillUI();

    // Aim: toggle between mouse and arrow keys; don't snap to mouse until mouse is moved
    const arrowHeld = keys.arrowUp || keys.arrowDown || keys.arrowLeft || keys.arrowRight;
    if (arrowHeld) {
        aimMode = 'keys';
        const dy = (keys.arrowDown ? 1 : 0) - (keys.arrowUp ? 1 : 0);
        const dx = (keys.arrowRight ? 1 : 0) - (keys.arrowLeft ? 1 : 0);
        if (dx !== 0 || dy !== 0) player.aimAngle = Math.atan2(dy, dx);
    } else if (aimMode === 'mouse') {
        player.aimAngle = Math.atan2(mouse.wy - player.y, mouse.wx - player.x);
    }
    // else aimMode === 'keys' and no arrow held: keep current player.aimAngle

    // Shooting
    if(player.cd>0) player.cd -= dt;
    else {
        player.shotCount++;
        let isPierce = (player.shotCount % 4 === 0) || (player.multiActive > 0);
        
        // Base Shot (use player.aimAngle)
        bullets.push({
            x:player.x, y:player.y, vx:Math.cos(player.aimAngle)*player.bulletSpd, vy:Math.sin(player.aimAngle)*player.bulletSpd,
            pierce: isPierce, hitList: [] 
        });

        // Multi-Shot Logic
        if(player.multiActive > 0) {
            let spread = 0.2; // roughly 12 degrees
            bullets.push({
                x:player.x, y:player.y, vx:Math.cos(player.aimAngle+spread)*player.bulletSpd, vy:Math.sin(player.aimAngle+spread)*player.bulletSpd,
                pierce: isPierce, hitList: [] 
            });
            bullets.push({
                x:player.x, y:player.y, vx:Math.cos(player.aimAngle-spread)*player.bulletSpd, vy:Math.sin(player.aimAngle-spread)*player.bulletSpd,
                pierce: isPierce, hitList: [] 
            });
        }

        player.cd=player.fr;
    }

    // Bullets (collect indices to remove, splice once after loop)
    const bulletsToRemove = [];
    bullets.forEach((b,i)=>{
        b.x += b.vx * dt; 
        b.y += b.vy * dt;
        if(b.x<0||b.x>ROOM_WIDTH||b.y<0||b.y>ROOM_HEIGHT) { bulletsToRemove.push(i); return; }
        for(let j=enemies.length-1; j>=0; j--){
            let e = enemies[j];
            const hitRad = e.size + 15;
            if (Math.abs(e.x - b.x) > hitRad || Math.abs(e.y - b.y) > hitRad) continue;
            if(getDistSq(e.x, e.y, b.x, b.y) < hitRad * hitRad) {
                if(b.pierce && b.hitList.includes(e.id)) continue;
                e.hp-=player.dmg; 
                addFloat(Math.floor(player.dmg), e.x, e.y, b.pierce?"#00f2fe":"#fff");
                particles.push({x:b.x, y:b.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, l:10, c:'#fff'});
                if(b.pierce) b.hitList.push(e.id); else bulletsToRemove.push(i);
                if(e.hp<=0) { killEnemy(e, j); checkWaveClear(); }
                if(!b.pierce) break; 
            }
        }
    });
    bulletsToRemove.sort((a,b)=>b-a);
    for(let idx of bulletsToRemove) bullets.splice(idx, 1);

    // Enemies
    enemies.forEach((e, index)=>{
        let a = Math.atan2(player.y-e.y, player.x-e.x);
        e.x += Math.cos(a)*e.spd * dt; 
        e.y += Math.sin(a)*e.spd * dt; 
        e.angle += e.spin * dt;
        if(e.x<e.size) e.x=e.size; if(e.x>ROOM_WIDTH-e.size) e.x=ROOM_WIDTH-e.size;
        if(e.y<e.size) e.y=e.size; if(e.y>ROOM_HEIGHT-e.size) e.y=ROOM_HEIGHT-e.size;

        // Kamikaze Flash
        if(e.type === 'kamikaze') {
            e.color = (Math.floor(Date.now() / 100) % 2 === 0) ? '#ff0000' : '#ffffff';
        }

        if(getDistSq(e.x, e.y, player.x, player.y) < (e.size+20)**2) {
            // GOD MODE CHECK
            const isGod = document.getElementById('dev-god').checked;
            if(isGod) {
                if(e.type === 'kamikaze') {
                    visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:100, op:1});
                    enemies.splice(index, 1);
                    addFloat("BLOCKED", player.x, player.y, "#00ffaa");
                }
                return;
            }

            // ION SHIELD LOGIC
            if(player.hasShield && player.shieldUp) {
                player.shieldUp = false;
                shake(15);
                visuals.push({type:'shieldBreak', x:player.x, y:player.y, r:60, op:1});
                
                // Push enemy back significantly
                let pushA = Math.atan2(e.y-player.y, e.x-player.x);
                e.x += Math.cos(pushA) * 300; 
                e.y += Math.sin(pushA) * 300;

                // KAMIKAZE SPECIFIC: If it hit the shield, it explodes safely (or dies)
                if(e.type === 'kamikaze') {
                    visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:100, op:1}); // Explode visual
                    enemies.splice(index, 1); // Die
                    addFloat("BLOCKED", player.x, player.y, "#00ffaa");
                }
                return; // NO DAMAGE TO PLAYER
            }

            // DAMAGE LOGIC (No Shield)
            if(e.type === 'kamikaze') {
                let dmg = Math.ceil(player.maxHp / 3);
                player.hp -= dmg;
                shake(30);
                visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:150, op:1}); 
                enemies.splice(index, 1);
                addFloat(`-${dmg}`, player.x, player.y, "#ff0000");
                updateHUD();
                if(player.hp<=0) { 
                    gameState="DEAD"; hideAll(); screens.death.classList.remove('hidden'); 
                    document.getElementById('final-score').innerText = `DIED IN ${DEPTH_NAMES[depthIndex]} - WAVE ${wave}`; 
                }
            } else {
                // Non-kamikaze: nerfed to 1 damage per 0.5s contact (not per frame)
                if (!e.lastHitPlayerAt || gameTime - e.lastHitPlayerAt > 500) {
                    e.lastHitPlayerAt = gameTime;
                    player.hp -= 1;
                    updateHUD();
                }
                if(player.hp<=0) { 
                    gameState="DEAD"; hideAll(); screens.death.classList.remove('hidden'); 
                    document.getElementById('final-score').innerText = `DIED IN ${DEPTH_NAMES[depthIndex]} - WAVE ${wave}`; 
                }
            }
        }
    });

    // XP (collect indices to remove, splice once after loop)
    if(xpOrbs.length > MAX_XP) xpOrbs.shift(); // Hard Cap
    const xpToRemove = [];
    xpOrbs.forEach((x,i)=>{
        let dSq = getDistSq(player.x, player.y, x.x, x.y);
        let pull = (player.hasMag && player.magActive>0);
        
        let ang = Math.atan2(player.y - x.y, player.x - x.x);

        if(pull) {
            x.vx += Math.cos(ang) * 1.5 * dt; 
            x.vy += Math.sin(ang) * 1.5 * dt;
            x.vx *= 0.92; x.vy *= 0.92;
            x.x += x.vx * dt; x.y += x.vy * dt;
        } else if (dSq < 60000) { 
            let speed = 2.5 * dt; 
            x.x += Math.cos(ang) * speed * 5; 
            x.y += Math.sin(ang) * speed * 5;
        }

        if(dSq<900) { 
            player.xp+=x.v; xpToRemove.push(i);
            if(gameState !== "DEAD") { checkLevelUp(); updateHUD(); }
        }
    });
    xpToRemove.sort((a,b)=>b-a);
    for(let idx of xpToRemove) xpOrbs.splice(idx, 1);

    // Cleanup (collect indices to remove, splice once after each loop)
    if(particles.length > MAX_PARTICLES) particles.shift(); // Hard Cap
    const particlesToRemove = [];
    particles.forEach((p,i)=>{ p.x+=p.vx * dt; p.y+=p.vy * dt; p.l -= dt; if(p.l<=0) particlesToRemove.push(i); });
    particlesToRemove.sort((a,b)=>b-a);
    for(let idx of particlesToRemove) particles.splice(idx, 1);

    const floatTextsToRemove = [];
    floatTexts.forEach((t,i)=>{ t.y -= 1 * dt; t.l -= dt; if(t.l<=0) floatTextsToRemove.push(i); });
    floatTextsToRemove.sort((a,b)=>b-a);
    for(let idx of floatTextsToRemove) floatTexts.splice(idx, 1);

    const visualsToRemove = [];
    visuals.forEach((v,i)=>{
        if(v.type==='shock') { v.r+=20 * dt; v.op-=0.04 * dt; }
        else if(v.type==='shieldBreak') { v.r+=4 * dt; v.op-=0.05 * dt; }
        else if(v.type==='spawn') { v.r-=2 * dt; v.op-=0.05 * dt; }
        if(v.op<=0 || v.r<0) visualsToRemove.push(i);
    });
    visualsToRemove.sort((a,b)=>b-a);
    for(let idx of visualsToRemove) visuals.splice(idx, 1);
}

function killEnemy(e, index) {
    enemies.splice(index,1); shake(5); 
    
    // Calculate XP value based on enemy stats
    let xpVal = e.xpValue || ((e.sides * e.sides) + (depthIndex * 20));
    
    // Create XP orbs - ALL BLUE, same size
    for(let i=0;i<3;i++) {
        xpOrbs.push({ 
            x:e.x, y:e.y, 
            vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, 
            v: xpVal / 3, // Split XP evenly across orbs
            color: "#00f2fe" // Always blue
        });
    }
    
    // Death particles in enemy color
    for(let k=0; k<6; k++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, l:30, c:e.color, s:5});
}

/* --- RENDER --- */
function renderBackground() {
    ctx.fillStyle="#020205"; ctx.fillRect(0,0,canvas.width,canvas.height);
}

const TAU = Math.PI * 2; // Reuse for arcs

function drawRoom() {
    const buffer = 100;
    viewBounds = {
        left: camera.x - buffer,
        right: camera.x + canvas.width + buffer,
        top: camera.y - buffer,
        bottom: camera.y + canvas.height + buffer
    };

    const palettes = [
        { bg: "#0a0a10", grid: "rgba(0, 242, 254, 0.05)", wall: "#00f2fe" },
        { bg: "#100a0a", grid: "rgba(255, 42, 109, 0.05)", wall: "#ff2a6d" },
        { bg: "#0a100a", grid: "rgba(0, 255, 170, 0.05)", wall: "#00ffaa" },
        { bg: "#100a10", grid: "rgba(255, 0, 222, 0.05)", wall: "#ff00de" },
        { bg: "#10100a", grid: "rgba(255, 165, 0, 0.05)", wall: "#ffa500" },
        { bg: "#0a0a0a", grid: "rgba(255, 255, 255, 0.05)", wall: "#ffffff" }
    ];
    const pal = palettes[depthIndex % palettes.length];

    ctx.fillStyle = "#020205"; ctx.fillRect(viewBounds.left, viewBounds.top, viewBounds.right - viewBounds.left, viewBounds.bottom - viewBounds.top);
    ctx.fillStyle = pal.bg; ctx.fillRect(0,0,ROOM_WIDTH, ROOM_HEIGHT);

    // Only draw grid lines that intersect the visible view (clamp to room bounds)
    ctx.strokeStyle=pal.grid; ctx.lineWidth=2;
    ctx.beginPath();
    const gridStep = 100;
    const xStart = Math.max(0, Math.floor(viewBounds.left / gridStep) * gridStep);
    const xEnd = Math.min(ROOM_WIDTH, Math.ceil(viewBounds.right / gridStep) * gridStep);
    const yStart = Math.max(0, Math.floor(viewBounds.top / gridStep) * gridStep);
    const yEnd = Math.min(ROOM_HEIGHT, Math.ceil(viewBounds.bottom / gridStep) * gridStep);
    for (let x = xStart; x <= xEnd; x += gridStep) { ctx.moveTo(x, 0); ctx.lineTo(x, ROOM_HEIGHT); }
    for (let y = yStart; y <= yEnd; y += gridStep) { ctx.moveTo(0, y); ctx.lineTo(ROOM_WIDTH, y); }
    ctx.stroke();

    ctx.strokeStyle = pal.wall; ctx.lineWidth = 10;
    ctx.shadowBlur = 20; ctx.shadowColor = pal.wall; ctx.strokeRect(0,0,ROOM_WIDTH,ROOM_HEIGHT); ctx.shadowBlur = 0;

    // MAGNET LINES
    if(player.hasMag && player.magActive > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random()*0.5 + 0.2})`;
        ctx.lineWidth = 1;
        ctx.shadowBlur = 10; ctx.shadowColor = "#fff";
        ctx.beginPath();
        xpOrbs.forEach(orb => {
            if(!isOnScreen(orb)) return; // Culling
            if(getDistSq(player.x, player.y, orb.x, orb.y) < 500000) {
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(orb.x, orb.y);
            }
        });
        ctx.stroke();
        ctx.restore();
    }

    // DRAW PORTAL
    if(portal.active) {
        ctx.save(); 
        ctx.translate(portal.x, portal.y); 
        
        ctx.save();
        ctx.rotate(portal.angle);
        ctx.strokeStyle = "#00ffaa"; ctx.lineWidth = 5; ctx.shadowBlur = 20; ctx.shadowColor = "#00ffaa";
        ctx.beginPath();
        for(let i=0; i<8; i++) {
            let th = (i/8)*TAU;
            ctx[i===0?'moveTo':'lineTo'](Math.cos(th)*portal.r, Math.sin(th)*portal.r);
        }
        ctx.closePath(); ctx.stroke();
        
        ctx.globalAlpha = 0.3 + Math.sin(Date.now()/200)*0.2;
        ctx.fillStyle = "#00ffaa"; ctx.fill();
        ctx.restore(); // Restore rotation
        
        ctx.globalAlpha = 1;
        
        ctx.fillStyle = "#fff"; ctx.font="bold 16px Montserrat";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.shadowBlur = 5; ctx.shadowColor = "#000";
        ctx.fillText("ENTER", 0, 0); 

        ctx.restore(); // Restore translation
    }

    // Draw snow particles (only in Zone 1)
    if (depthIndex === 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        SNOW_PARTICLES.forEach(p => {
            if (p.y < camera.y + canvas.height && p.y > camera.y - 50) { // Only draw visible particles
                ctx.fillStyle = p.c;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.restore();
    }

    // Visuals
    visuals.forEach(v => {
        if(v.type==='shock') { ctx.strokeStyle=`rgba(0,242,254,${v.op})`; ctx.lineWidth=8; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.stroke(); }
        else if(v.type==='shieldBreak') { ctx.strokeStyle=`rgba(0,255,170,${v.op})`; ctx.lineWidth=5; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.stroke(); }
        else if(v.type==='spawn') { ctx.fillStyle=`rgba(255,255,255,${v.op})`; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.fill(); }
    });

    if(player.hasShield && player.shieldUp) {
        ctx.save(); ctx.translate(player.x, player.y);
        ctx.strokeStyle = `rgba(0, 255, 170, ${0.4 + Math.sin(Date.now()/150)*0.2})`; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, 50, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
    }

    // BLOOM ON
    const useBloom = gameSettings.bloom; 
    if(useBloom) ctx.globalCompositeOperation = 'lighter';
    
    // Draw XP Orbs - ALL BLUE, SAME SIZE (6px)
    xpOrbs.forEach(x=>{ 
        if(!isOnScreen(x)) return;
        if(useBloom) { ctx.shadowBlur=10; ctx.shadowColor= "#00f2fe"; }
        ctx.fillStyle= "#00f2fe"; 
        ctx.beginPath(); 
        ctx.arc(x.x,x.y, 6, 0,TAU); 
        ctx.fill(); 
        if(useBloom) ctx.shadowBlur=0; 
    });
    
    particles.forEach(p=>{ 
        if(!isOnScreen(p)) return;
        ctx.fillStyle=p.c; ctx.globalAlpha=p.l/30; ctx.beginPath(); ctx.arc(p.x,p.y,p.s||3,0,TAU); ctx.fill(); 
    });
    ctx.globalAlpha=1;
    
    if(useBloom) { ctx.shadowBlur = 10; }
    bullets.forEach(b=>{ 
        if(!isOnScreen(b)) return;
        ctx.fillStyle = b.pierce ? "#fff" : "#00f2fe"; 
        if(useBloom) ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(b.x,b.y,4,0,TAU); ctx.fill(); 
    });
    ctx.shadowBlur=0;

    enemies.forEach(e=>{
        if(!isOnScreen(e)) return;
        ctx.strokeStyle = e.color; ctx.lineWidth = 3; ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        if(useBloom) { ctx.shadowBlur=10; ctx.shadowColor=e.color; }
        ctx.beginPath();
        for(let i=0; i<e.sides; i++) {
            const theta = (i / e.sides) * Math.PI * 2;
            ctx[i===0?'moveTo':'lineTo'](Math.cos(theta)*e.size, Math.sin(theta)*e.size);
        }
        ctx.closePath(); ctx.stroke(); ctx.restore(); ctx.shadowBlur=0;
    });
    ctx.globalCompositeOperation = 'source-over';

    // Player (No dot) - use aim angle (arrow keys or mouse)
    const drawAngle = (typeof player.aimAngle === 'number') ? player.aimAngle : Math.atan2(mouse.wy - player.y, mouse.wx - player.x);
    ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(drawAngle);
    ctx.fillStyle = "#000"; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
    ctx.shadowBlur=15; ctx.shadowColor="#00f2fe";
    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-15, 15); ctx.lineTo(-8, 0); ctx.lineTo(-15, -15); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.shadowBlur=0;
    ctx.restore();

    ctx.font = "900 20px 'Montserrat'"; ctx.textAlign="center";
    floatTexts.forEach(t=>{ 
        if(!isOnScreen(t)) return;
        ctx.fillStyle=t.c; ctx.globalAlpha=t.l/60; ctx.fillText(t.t, t.x, t.y); 
    });
    ctx.globalAlpha=1;
}

window.addEventListener('resize', ()=>{ applyCanvasResolution(); });

window.addEventListener('wheel', (e) => {
    if (e.ctrlKey) e.preventDefault();
}, { passive: false });

window.addEventListener('gesturestart', (e) => { e.preventDefault(); });
window.addEventListener('gesturechange', (e) => { e.preventDefault(); });
window.addEventListener('gestureend', (e) => { e.preventDefault(); });

// FIX FOR CHROMEBOOK INPUT ISSUE
window.addEventListener('focus', () => {
    // Reset all keys to false when window regains focus
    keys = { w:false, a:false, s:false, d:false, space:false, q:false, e:false, arrowUp:false, arrowDown:false, arrowLeft:false, arrowRight:false };
});

window.addEventListener('keydown', e=>{ 
    // Prevent default for space and arrows to avoid scrolling
    if(e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'ArrowLeft' || e.code === 'ArrowRight') e.preventDefault();
    if((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=' || e.key === '-' || e.key === '0')) e.preventDefault();
    
    if(e.key==='w' || e.key==='W') keys.w=true; 
    if(e.key==='a' || e.key==='A') keys.a=true; 
    if(e.key==='s' || e.key==='S') keys.s=true; 
    if(e.key==='d' || e.key==='D') keys.d=true; 
    if(e.key===' ') { keys.space=true; } 
    if(e.key==='q' || e.key==='Q') keys.q=true; 
    if(e.key==='e' || e.key==='E') keys.e=true;
    if(e.code==='ArrowUp') keys.arrowUp=true;
    if(e.code==='ArrowDown') keys.arrowDown=true;
    if(e.code==='ArrowLeft') keys.arrowLeft=true;
    if(e.code==='ArrowRight') keys.arrowRight=true;
    if((e.code==='ArrowUp' || e.code==='ArrowDown' || e.code==='ArrowLeft' || e.code==='ArrowRight') && gameState === 'PLAY') {
        aimMode = 'keys';
        canvas.style.cursor = "none";
    }
    
    if(e.key==='Escape') { 
        if(!screens.settings.classList.contains('hidden')) closeSettings();
        else if(!screens.learn.classList.contains('hidden')) goBackFromArchive();
        else togglePause();
    }
    // DEV CONSOLE TOGGLE (Backslash)
    if(e.key === '\\') {
        const console = document.getElementById('dev-console');
        console.style.display = (console.style.display === 'block') ? 'none' : 'block';
    }
});

window.addEventListener('keyup', e=>{ 
    if(e.key==='w' || e.key==='W') keys.w=false; 
    if(e.key==='a' || e.key==='A') keys.a=false; 
    if(e.key==='s' || e.key==='S') keys.s=false; 
    if(e.key==='d' || e.key==='D') keys.d=false; 
    if(e.key===' ') keys.space=false; 
    if(e.key==='q' || e.key==='Q') keys.q=false; 
    if(e.key==='e' || e.key==='E') keys.e=false;
    if(e.code==='ArrowUp') keys.arrowUp=false;
    if(e.code==='ArrowDown') keys.arrowDown=false;
    if(e.code==='ArrowLeft') keys.arrowLeft=false;
    if(e.code==='ArrowRight') keys.arrowRight=false;
});

window.addEventListener('mousemove', e=>{ 
    const rect = canvas.getBoundingClientRect();
    const scale = Math.min(rect.width / canvas.width, rect.height / canvas.height);
    const offsetX = (rect.width - canvas.width * scale) / 2;
    const offsetY = (rect.height - canvas.height * scale) / 2;
    mouse.x = (e.clientX - rect.left - offsetX) / scale;
    mouse.y = (e.clientY - rect.top - offsetY) / scale;
    if (gameState === 'PLAY' && Date.now() > aimModeLockUntil) {
        aimMode = 'mouse';
        updateCanvasCursor();
    }
});

// MOUSE DOWN/UP FOR CLICK-TO-CONTINUE
window.addEventListener('mousedown', e=>{ mouse.down = true; });
window.addEventListener('mouseup', e=>{ mouse.down = false; });

/* --- DEV CONSOLE SCRIPTS --- */
function updatePlayerStat(stat, val) {
    player[stat] = parseFloat(val);
    addFloat(`${stat.toUpperCase()} UPDATED`, player.x, player.y, "#00f2fe");
}

function devSkipWave() {
    if(gameState !== "PLAY" || portal.active) return;
    enemies.forEach(e => {
        for(let i=0;i<3;i++) xpOrbs.push({ 
            x:e.x, y:e.y, 
            vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, 
            v:(e.xpValue || (e.sides*5))/3,
            color: "#00f2fe"
        });
    });
    enemies = [];
    addFloat("WAVE WIPED", player.x, player.y, "#ff9900");
    if (wave >= WAVES_PER_DEPTH) {
        portal.active = true;
        portal.x = ROOM_WIDTH / 2;
        portal.y = ROOM_HEIGHT / 2;
        addFloat("PORTAL OPEN", portal.x, portal.y - 120, "#00ffaa");
    } else {
        spawnNextWave(); // Immediate spawn when spamming skip
    }
}

function devNextZone() {
    if(gameState !== "PLAY") return;
    enemies = [];
    depthIndex++;
    if(depthIndex >= DEPTH_NAMES.length) depthIndex = 0;
    showZoneIntro();
}

function devUnlockAll() {
    player.hasShock = true;
    player.hasMag = true;
    player.hasShield = true;
    player.shieldUp = true;
    player.hasMulti = true;
    updateSkillUI();
    addFloat("MODULES UNLOCKED", player.x, player.y, "#ff00de");
}

function devInstantLevel() {
    if(gameState !== "PLAY") return;
    player.xp = player.req;
    checkLevelUp();
    addFloat("LEVEL UP READY", player.x, player.y, "#00ffaa");
}

// Monkey Patch Trivia for Skip
const originalStartTrivia = startTrivia;
startTrivia = function() {
    const skip = document.getElementById('dev-trivia').checked;
    if(skip) {
        // Skip trivia logic, go straight to upgrade
        // Logic copied from checkAnswer(true)
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });

        if(player.lvl % 4 === 0 && unacquired.length > 0) triggerUnlock(unacquired);
        else triggerUpgrade();
    } else {
        originalStartTrivia();
    }
};

// Dev Update Loop Hook
window.devUpdate = function() {
    const isGod = document.getElementById('dev-god').checked;
    if(isGod && gameState === "PLAY") {
        // Instant Reload
        player.cd = 0;
        // Instant Skill Charge
        if(player.hasShock) player.shockTimer = player.shockMax;
        if(player.hasMag && player.magActive <= 0) player.magTimer = player.magMax;
        if(player.hasMulti && player.multiActive <= 0) player.multiTimer = player.multiMax;
        if(player.hasShield && !player.shieldUp) player.shieldTimer = 0; // Will trigger auto recharge logic in update
        player.hp = player.maxHp;
    }
};

applyCanvasResolution();
renderBackground();

</script>
</body>
</html>
