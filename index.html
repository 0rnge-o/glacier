<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glacier Crawler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Montserrat', sans-serif; user-select: none; touch-action: none; }

        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; touch-action: none; image-rendering: crisp-edges; image-rendering: pixelated; }

        /* Responsive scaling */
        @media (max-width: 768px) {
            .overlay { padding: 10px; }
            h1 { font-size: 40px !important; margin: 0 0 5px 0; letter-spacing: 2px; }
            h2 { font-size: 24px !important; margin-bottom: 20px; }
            .menu-btn { font-size: 14px !important; padding: 12px 20px !important; width: 280px !important; margin: 5px !important; }
            .modal-content { padding: 20px !important; max-width: 95% !important; }
            .archive-section-title { font-size: 18px !important; }
            .archive-section-body { font-size: 14px !important; }
            .zone-title { font-size: 40px !important; }
            .zone-description { font-size: 16px !important; max-height: 50vh !important; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 32px !important; letter-spacing: 1px; }
            h2 { font-size: 20px !important; margin-bottom: 15px; }
            .menu-btn { font-size: 12px !important; padding: 10px 15px !important; width: 240px !important; }
            .modal-content { padding: 15px !important; }
            .archive-section-title { font-size: 16px !important; }
            .archive-section-body { font-size: 12px !important; }
            .zone-title { font-size: 32px !important; }
            .zone-description { font-size: 14px !important; }
        }

        @media (max-height: 600px) {
            .overlay { padding: 5px; }
            h1 { font-size: 28px !important; margin: 0 0 3px 0; }
            h2 { font-size: 18px !important; margin-bottom: 10px; }
            .menu-btn { font-size: 12px !important; padding: 8px 15px !important; margin: 3px !important; }
        }

        /* OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(2, 2, 5, 0.95);
            z-index: 10; color: white; transition: opacity 0.2s; backdrop-filter: blur(5px);
        }   
        .hidden { display: none !important; }

        h1 { font-size: 70px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 5px; color: #fff; text-shadow: 0 0 20px #00f2fe, 0 0 40px #00f2fe; }
        h2 { color: #00f2fe; margin-bottom: 50px; font-weight: 900; text-shadow: 0 0 10px #00f2fe; }

        .menu-btn {
            background: rgba(0,0,0,0.8); color: #fff;
            font-family: 'Montserrat', sans-serif; font-size: 18px; font-weight: 700;
            padding: 15px 40px; margin: 10px; /* Even Spacing */
            border: 2px solid #fff; cursor: pointer; width: 320px;
            text-align: center; transition: 0.1s; box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        .menu-btn:hover { background: #fff; color: #000; border-color: #00f2fe; transform: scale(1.02); box-shadow: 0 0 20px #00f2fe; }

        /* HUD */
        #hud { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 5; }
        .bar-wrap { width: 350px; height: 16px; background: #0a0a0a; margin-bottom: 10px; border: 2px solid #444; box-shadow: 0 0 10px #000; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s linear; }
        #hp-fill { background: #ff2a6d; box-shadow: 0 0 10px #ff2a6d; }
        #xp-fill { background: #00f2fe; width: 0%; box-shadow: 0 0 10px #00f2fe; }

        .depth-info { font-size: 24px; color: #00ffaa; letter-spacing: 2px; margin-bottom: 5px; font-weight: 900; text-shadow: 0 0 10px #00ffaa; }
        .wave-info { font-size: 18px; color: #ff9900; font-weight: 700; margin-top:5px; }

        #fps-counter { position: absolute; top: 20px; right: 20px; color: #00ffaa; font-weight: bold; font-family: monospace; z-index: 5; display: none; }

        #version-badge { position: absolute; bottom: 20px; left: 20px; color: #666; font-size: 14px; font-weight: 400; z-index: 11; pointer-events: none; }

        /* SKILLS */
        #skills-row { display: flex; gap: 15px; margin-top: 20px; pointer-events: auto; }
        .skill-box {
            width: 60px; height: 60px; background: #0a0a0f; border: 2px solid #333;
            position: relative; display: none; justify-content: center; align-items: center;
            transition: all 0.2s;
        }
        .skill-box.cooling { border-color: #444; box-shadow: inset 0 0 0 2px rgba(0,0,0,0.6); filter: saturate(0.7) brightness(0.85); }
        .skill-box.ready { border-color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.4); transform: scale(1.05); }
        .skill-key { position: absolute; top: -10px; left: -5px; background: #000; border: 1px solid #666; font-size: 10px; padding: 2px 5px; color: #fff; font-weight: bold; z-index: 4; }
        .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 3; transition: height 0.08s linear, opacity 0.12s linear; opacity: 0.95; }
        .skill-box.cooling .cooldown-overlay {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.88), rgba(0, 242, 254, 0.18));
            border-top: 2px solid rgba(0, 242, 254, 0.55);
            box-shadow: inset 0 12px 22px rgba(0,0,0,0.65);
        }
        .skill-box.ready .cooldown-overlay { opacity: 0; }
        
        .ico-shock { width: 24px; height: 24px; border-radius: 50%; border: 3px solid #00f2fe; box-shadow: 0 0 10px #00f2fe; }
        .ico-mag { 
            width: 26px; height: 26px;
            position: relative;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 50%, rgba(0, 242, 254, 0.95) 0%, rgba(0, 242, 254, 0.22) 35%, rgba(0, 0, 0, 0) 62%);
            border: 2px solid rgba(0, 242, 254, 0.9);
            box-shadow: 0 0 14px rgba(0, 242, 254, 0.75), inset 0 0 10px rgba(0, 242, 254, 0.35);
        }
        .ico-mag::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.75);
            transform: translate(-50%, -50%) scaleX(1.08) rotate(20deg);
            box-shadow: 0 0 8px rgba(255,255,255,0.35);
        }
        .ico-mag::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.92);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.55);
        }
        .ico-shield { width: 22px; height: 22px; border: 4px solid #00ffaa; border-radius: 50%; box-shadow: 0 0 10px #00ffaa; background: rgba(0, 255, 170, 0.2); }
        .ico-multi { width: 6px; height: 18px; background: #ff9900; box-shadow: 10px 0 0 #ff9900, -10px 0 0 #ff9900, 0 0 10px #ff9900; }

        /* MODALS */
        .modal-content { background: #050508; border: 2px solid #00f2fe; padding: 40px; text-align: center; max-width: 900px; width: 90%; box-shadow: 0 0 50px rgba(0, 242, 254, 0.2); }
        .ans-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; }
        .upgrade-btn { border: 1px solid #555; padding: 25px; background: #111; cursor: pointer; text-align: left; position: relative; transition: 0.2s; }
        .upgrade-btn:hover { border-color: #00f2fe; background: #1a1a20; transform: translateY(-5px); box-shadow: 0 0 15px rgba(0, 242, 254, 0.2); }
        .u-title { color: #ffd700; font-size: 24px; margin-bottom: 8px; font-weight: 900; }
        .u-desc { color: #aaa; font-size: 15px; line-height: 1.4; }
        .u-tag { position: absolute; top: 10px; right: 10px; font-size: 10px; background: #333; padding: 3px 8px; border-radius: 4px; color: #fff; }
        .unlock-btn { border-color: #ff00de; } .unlock-btn .u-title { color: #ff00de; }

        /* TRIVIA */
        #trivia-overlay { background: rgba(0,0,0,0.95); }
        .trivia-box { width: 700px; background: #0a0a0f; border: 2px solid #fff; padding: 30px; text-align: center; box-shadow: 0 0 30px rgba(255,255,255,0.1); }
        .t-ques { font-size: 24px; margin-bottom: 30px; color: #fff; font-weight: 700; line-height: 1.4; }
        .t-opts { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .t-btn { background: #111; border: 1px solid #555; color: #fff; padding: 20px; font-size: 16px; cursor: pointer; font-weight: bold; transition:0.2s; min-height: 110px; display: flex; align-items: center; justify-content: center; text-align: center; }
        .t-btn-text { display: block; width: 100%; }
        .t-btn:hover { background: #15151c; color: #fff; border-color: #00f2fe; box-shadow: 0 0 16px rgba(0, 242, 254, 0.18); }
        .t-btn.disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
        .t-status { font-size: 16px; color: #ff2a6d; margin-bottom: 15px; height: 20px; letter-spacing: 2px; font-weight: 900; }

        .gloss-term { color: #00f2fe; cursor: help; text-shadow: 0 0 8px rgba(0, 242, 254, 0.35); transition: 0.12s; }
        .gloss-term:hover { color: #fff; text-shadow: 0 0 14px rgba(0, 242, 254, 0.8); }
        #glossary-tooltip { position: fixed; left: 0; top: 0; max-width: 320px; padding: 12px 14px; background: rgba(5, 5, 8, 0.98); border: 1px solid #00f2fe; box-shadow: 0 0 25px rgba(0, 242, 254, 0.25); color: #fff; z-index: 2000; opacity: 0; transform: translateY(6px); pointer-events: none; transition: opacity 0.12s, transform 0.12s; }
        #glossary-tooltip.show { opacity: 1; transform: translateY(0px); }
        #glossary-tooltip .gt-title { font-weight: 900; letter-spacing: 1px; color: #00f2fe; margin-bottom: 6px; }
        #glossary-tooltip .gt-body { color: #ddd; font-size: 14px; line-height: 1.35; }

        /* PAUSE & SETTINGS */
        #pause-content, #settings-content {
            background: #0a0a0f; border: 1px solid #444; padding: 40px; width: 600px;
            display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px;
            align-items: center; /* Centered buttons */
        }
        #pause-content { display: grid; grid-template-columns: 1fr 1fr; align-items: start; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 16px; color: #ccc; border-bottom: 1px solid #222; padding-bottom: 5px; }
        .stat-val { font-weight: bold; color: #fff; }
        
        /* LEARN CARDS */
        .fact-card { 
            background: rgba(20,20,30, 0.9); border: 1px solid #444; padding: 30px; 
            cursor: pointer; transition: all 0.2s; position: relative; min-height: 120px;
            display: flex; flex-direction: column; justify-content: center;
        }
        .fact-card:hover { border-color: #00f2fe; background: rgba(30,30,40,1); }
        .fact-card.revealed { border-color: #00f2fe; background: #051a24; }
        .fact-a-wrap { margin-top: 15px; border-top: 1px solid #333; padding-top: 15px; display: none; }
        .revealed .fact-a-wrap { display: block; }

        /* TRANSITION SCREEN */
        #depth-screen {
            background: #000;
        }
        
        /* ZONE INTRO SCREEN */
        #zone-intro {
            background: rgba(0,0,0,0.98);
        }
        .zone-content {
            background: #0a0a0f;
            border: 2px solid #00f2fe;
            padding: 40px;
            max-width: 900px;
            width: 80%;
            box-shadow: 0 0 50px rgba(0, 242, 254, 0.3);
            text-align: center;
        }
        .zone-title {
            font-size: 48px;
            color: #00f2fe;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 15px #00f2fe;
        }
        .zone-description {
            font-size: 20px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #333;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            text-align: left;
        }
        .continue-prompt {
            font-size: 18px;
            color: #00ffaa;
            margin-top: 30px;
            animation: pulse 1.5s infinite;
            text-shadow: 0 0 10px #00ffaa;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* --- DEV CONSOLE STYLES --- */
        #dev-console {
            position: absolute; top: 10px; right: 10px; width: 300px;
            background: rgba(0, 0, 0, 0.9); border: 1px solid #00f2fe;
            color: #00f2fe; font-family: monospace; z-index: 1000;
            padding: 15px; display: none; box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
        }
        #dev-console h3 { margin: 0 0 10px 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .dev-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; }
        .dev-input { width: 60px; background: #111; border: 1px solid #555; color: #fff; padding: 2px; }
        .dev-btn { width: 100%; background: #222; border: 1px solid #00f2fe; color: #fff; padding: 5px; cursor: pointer; margin-top: 5px; font-family: monospace; }
        .dev-btn:hover { background: #00f2fe; color: #000; }
        .dev-chk { cursor: pointer; }
        
        /* ARCHIVE TABS */
        .archive-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .archive-tab {
            background: #111;
            border: 1px solid #444;
            color: #ccc;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            font-weight: bold;
        }
        .archive-tab:hover {
            background: #222;
            border-color: #00f2fe;
        }
        .archive-tab.active {
            background: #00f2fe;
            color: #000;
            border-color: #00f2fe;
            box-shadow: 0 0 10px #00f2fe;
        }
        .archive-content {
            display: none;
            width: 80%;
            overflow-y: auto;
            max-height: 60vh;
            padding-bottom: 50px;
        }
        .archive-content.active {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .archive-blurbs {
            width: 80%;
            overflow-y: auto;
            max-height: 60vh;
            padding-bottom: 50px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .archive-section {
            width: 100%;
            text-align: left;
            background: rgba(20,20,30, 0.9);
            border: 1px solid #333;
            padding: 22px;
        }
        .archive-section-title {
            color: #00f2fe;
            font-weight: 900;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 12px;
            font-size: 18px;
        }
        .archive-section-body { color: #ddd; font-size: 16px; line-height: 1.55; }
        .archive-section-body ul { margin: 12px 0 0 18px; padding: 0; }
        .archive-section-body li { margin: 8px 0; }
        .question-count {
            color: #00ffaa;
            font-size: 14px;
            margin-left: 10px;
        }
        
        /* ZOOM CONTROLS */
        .zoom-slider {
            width: 100%;
            height: 20px;
            margin: 10px 0;
            background: #111;
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #00f2fe;
            cursor: pointer;
            box-shadow: 0 0 10px #00f2fe;
        }
        .zoom-preview {
            width: 200px;
            height: 150px;
            margin: 20px auto;
            border: 2px solid #00f2fe;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00f2fe;
            font-size: 14px;
        }
        .zoom-value {
            color: #00f2fe;
            font-weight: bold;
            margin-top: 5px;
        }
        
        /* MOUSE TYPE SELECTOR */
        .mouse-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            width: 100%;
        }
        .mouse-option {
            padding: 20px;
            background: #111;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .mouse-option:hover {
            border-color: #00f2fe;
            background: #1a1a20;
        }
        .mouse-option.active {
            border-color: #00f2fe;
            background: rgba(0, 242, 254, 0.1);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.3);
        }
        .mouse-preview {
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 30px;
        }
        .mouse-preview.crosshair { color: #fff; }
        .mouse-preview.pointer { color: #00f2fe; }
        .mouse-preview.circle { color: #fff; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="fps-counter">FPS: 60</div>

    <div id="dev-console">
        <h3>DEV CONSOLE (Toggle: .)</h3>
        
        <div class="dev-row">
            <span>GOD MODE (No CD/Dmg)</span>
            <input type="checkbox" id="dev-god" class="dev-chk">
        </div>
        <div class="dev-row">
            <span>DISABLE TRIVIA</span>
            <input type="checkbox" id="dev-trivia" class="dev-chk">
        </div>
        
        <div style="margin-top:10px; color:#aaa; font-size:12px;">PLAYER STATS</div>
        <div class="dev-row">
            <span>Damage</span>
            <input type="number" id="dev-dmg" class="dev-input" onchange="updatePlayerStat('dmg', this.value)">
        </div>
        <div class="dev-row">
            <span>Fire Rate (frames)</span>
            <input type="number" id="dev-fr" class="dev-input" onchange="updatePlayerStat('fr', this.value)">
        </div>
        <div class="dev-row">
            <span>Speed</span>
            <input type="number" id="dev-spd" class="dev-input" onchange="updatePlayerStat('spd', this.value)">
        </div>
        <div class="dev-row">
            <span>Bullet Speed</span>
            <input type="number" id="dev-bspd" class="dev-input" onchange="updatePlayerStat('bulletSpd', this.value)">
        </div>

        <div style="margin-top:10px; color:#aaa; font-size:12px;">NAVIGATION</div>
        <div class="dev-row">
            <span>Set Depth (0-6)</span>
            <input type="number" id="dev-depth" class="dev-input" min="0" max="6" onchange="devSetDepth(this.value)">
        </div>
        <button class="dev-btn" onclick="devInstantLevel()">INSTANT LEVEL UP</button>
        <button class="dev-btn" onclick="devSkipWave()">SKIP WAVE (KILL ALL)</button>
        <button class="dev-btn" onclick="devNextZone()">NEXT ZONE (TELEPORT)</button>
        <button class="dev-btn" onclick="devUnlockAll()">UNLOCK ALL MODULES</button>
    </div>

    <!-- ZONE INTRODUCTION SCREEN -->
    <div id="zone-intro" class="overlay hidden">
        <div class="zone-content">
            <div class="zone-title" id="zone-title">ZONE NAME</div>
            <div class="zone-description" id="zone-description">
                Loading zone description...
            </div>
            <div class="continue-prompt" id="zone-continue">Press ANY KEY or CLICK to continue...</div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>GLACIER CRAWLER</h1>
        <h2 style="font-size: 24px; letter-spacing: 2px;">DEEP DIVE PROTOCOL</h2>
        <button class="menu-btn" onclick="showTutorial()">HOW TO PLAY</button>
        <button class="menu-btn" onclick="startGame()">START</button>
        <button class="menu-btn" onclick="openSettings('MENU')">SETTINGS</button>
        <button class="menu-btn" onclick="showLearn()">LEARN</button>
        <div id="version-badge">v6.7</div>
    </div>

    <div id="tutorial-screen" class="overlay hidden">
        <h1>HOW TO PLAY</h1>
        <div style="display: flex; gap: 30px; align-items: flex-start; margin-bottom: 30px;">
            <div style="color: #ccc; font-size: 18px; max-width: 500px; text-align: left;">
                <div style="margin-bottom: 20px;"><strong>MOVEMENT:</strong><br>WASD to move • Arrow keys or mouse to aim • Auto-fire at cursor</div>
                <div style="margin-bottom: 20px;"><strong>COMBAT:</strong><br>Every 4th shot pierces enemies • Survive waves of geometric shapes • Collect blue XP orbs</div>
                <div style="margin-bottom: 20px;"><strong>ABILITIES:</strong><br>SPACE - Shockwave<br>Q - Gravity Well (pulls XP orbs)<br>E - Multi-shot (fires 3 bullets)<br>Shield - Recharges automatically</div>
                <div style="margin-bottom: 20px;"><strong>PROGRESSION:</strong><br>Gain XP to level up • Every 4th level unlocks new abilities • Choose stat upgrades between levels</div>
                <div style="margin-bottom: 20px;"><strong>TIPS:</strong><br>Large enemies (6+ sides) may spawn smaller versions • Keep moving to avoid damage • Use abilities when overwhelmed</div>
            </div>
            <div style="color: #ccc; font-size: 16px; max-width: 300px; text-align: center;">
                <div style="margin-bottom: 15px;"><strong>SHOOTING DEMONSTRATION:</strong></div>
                <canvas id="tutorial-canvas" width="280" height="200" style="border: 1px solid #444; background: #020205;"></canvas>
                <div style="margin-top: 10px; font-size: 14px;">
                    <div>Player shoots continuously</div>
                    <div>4th shot (white) pierces</div>
                    <div>Regular shots (blue)</div>
                </div>
            </div>
        </div>
        <button class="menu-btn" onclick="closeTutorial()">BACK</button>
    </div>

    <div id="settings-screen" class="overlay hidden">
        <h1>SETTINGS</h1>
        <div id="settings-content">
            <!-- GRAPHICS QUALITY -->
            <h3 style="color:#00f2fe; margin-top: 0; width: 100%; text-align: center;">GRAPHICS QUALITY</h3>
            <button class="menu-btn" id="btn-bloom" onclick="toggleBloom()" style="margin:0; width:100%">
                EFFECTS: LOW
            </button>
            <button class="menu-btn" id="btn-fps" onclick="toggleFps()" style="margin:0; width:100%">FPS: OFF</button>
            
            <!-- MOUSE TYPE SELECTOR -->
            <h3 style="color:#00f2fe; margin-top: 30px; width: 100%; text-align: center;">MOUSE TYPE</h3>
            <div class="mouse-type-selector">
                <div class="mouse-option active" onclick="changeMouseType('crosshair')">
                    <div class="mouse-preview crosshair">+</div>
                    <div>Crosshair</div>
                </div>
                <div class="mouse-option" onclick="changeMouseType('pointer')">
                    <div class="mouse-preview pointer">☝</div>
                    <div>Pointer</div>
                </div>
                <div class="mouse-option" onclick="changeMouseType('circle')">
                    <div class="mouse-preview circle">○</div>
                    <div>Circle</div>
                </div>
            </div>
        </div>
        <button class="menu-btn" onclick="closeSettings()">BACK</button>
    </div>

    <div id="win-screen" class="overlay hidden">
        <h1 style="color: #00ffaa; font-size: 80px; text-shadow: 0 0 30px #00ffaa;">MISSION COMPLETE</h1>
        <h2 style="color: #fff;">GLACIER CONQUERED</h2>
        <div style="color: #ccc; margin-bottom: 30px; font-size: 18px;">ALL SAMPLES COLLECTED</div>
        <div id="win-time" style="color: #00f2fe; margin-bottom: 30px; font-size: 20px; font-weight: bold;">Time: 00:00</div>
        <button class="menu-btn" onclick="startGame()">RESTART</button>
        <button class="menu-btn" onclick="goHome()">MAIN MENU</button>
    </div>

    <div id="depth-screen" class="overlay hidden">
        <h1 id="depth-title" style="font-size:60px;">ZONE 1</h1>
        <h2 id="depth-sub" style="color:#aaa;">ENTERING...</h2>
    </div>

    <div id="pause-screen" class="overlay hidden">
        <h1>SYSTEM PAUSED</h1>
        <div id="pause-content">
            <div>
                <h3 style="color:#00f2fe; border-bottom:2px solid #00f2fe; padding-bottom:10px;">STATS</h3>
                <div class="stat-row"><span>Damage</span><span class="stat-val" id="st-dmg">0</span></div>
                <div class="stat-row"><span>Fire Rate</span><span class="stat-val" id="st-fr">0</span></div>
                <div class="stat-row"><span>Speed</span><span class="stat-val" id="st-spd">0</span></div>
                <div class="stat-row"><span>Max HP</span><span class="stat-val" id="st-hp">0</span></div>
            </div>
            <div>
                <h3 style="color:#ff00de; border-bottom:2px solid #ff00de; padding-bottom:10px;">MODULES</h3>
                <div id="st-mods"></div>
            </div>
        </div>
        <button class="menu-btn" onclick="togglePause()">RESUME</button>
        <button class="menu-btn" onclick="openSettings('PAUSE')">SETTINGS</button>
        <button class="menu-btn" onclick="showLearn()">LEARN</button>
        <button class="menu-btn" style="width:200px; padding:15px; margin-top:0;" onclick="goHome()">QUIT</button>
    </div>

    <div id="learn-screen" class="overlay hidden">
        <h1 style="font-size: 40px; margin-bottom: 20px;">GLACIER LEARN</h1>
        <div style="margin-bottom:10px; color:#aaa">ZONE BRIEFS + DEFINITIONS</div>
        
        <!-- TAB NAVIGATION -->
        <div id="archive-container" class="archive-blurbs"></div>
        
        <button class="menu-btn" onclick="goBackFromArchive()">BACK</button>
    </div>

    <div id="death-screen" class="overlay hidden">
        <h1 style="color: #ff2a6d;">run over</h1>
        <h2 id="final-score"></h2>
        <div id="death-time" style="color: #00f2fe; margin-bottom: 30px; font-size: 20px; font-weight: bold;">Time: 00:00</div>
        <button class="menu-btn" onclick="startGame()">REBOOT</button>
        <button class="menu-btn" onclick="goHome()">MAIN MENU</button>
    </div>

    <div id="hud" class="hidden">
        <div class="depth-info" id="level-tag">ZONE OF ACCUMULATION</div>
        <div class="wave-info" id="wave-tag">WAVE 1/10</div>
        
        <div class="bar-wrap" style="margin-top:15px;"><div id="hp-fill" class="bar-fill"></div></div>
        <div class="bar-wrap" style="border-color:#005566; height:10px;"><div id="xp-fill" class="bar-fill"></div></div>
        <div style="font-size:14px; color:#888; font-weight: bold; margin-top:5px;">LVL <span id="lvl-txt" style="color:#fff; font-size:18px;">1</span></div>

        <div id="skills-row">
            <div id="skill-shock" class="skill-box"><div class="skill-key">SPC</div><div class="ico-shock"></div><div id="cd-shock" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-mag" class="skill-box"><div class="skill-key">Q</div><div class="ico-mag"></div><div id="cd-mag" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-multi" class="skill-box"><div class="skill-key">E</div><div class="ico-multi"></div><div id="cd-multi" class="cooldown-overlay" style="height:100%"></div></div>
            <div id="skill-shield" class="skill-box"><div class="ico-shield"></div><div id="cd-shield" class="cooldown-overlay" style="height:100%"></div></div>
        </div>
    </div>

    <div id="trivia-overlay" class="overlay hidden">
        <div class="trivia-box">
            <div style="color:#00f2fe; margin-bottom:10px; font-weight:900; letter-spacing:2px">LEVEL UP PROTOCOL</div>
            <div class="t-status" id="t-status"></div>
            <div class="t-ques" id="t-ques">?</div>
            <div class="t-opts" id="t-opts"></div>
            <div style="margin-top:20px; font-size:12px; color:#666;">CORRECT: UPGRADE<br>WRONG: TRY AGAIN NEXT LEVEL</div>
        </div>
    </div>

    <div id="answer-explanation-overlay" class="overlay hidden">
        <div class="trivia-box">
            <div style="color:#00f2fe; margin-bottom:10px; font-weight:900; letter-spacing:2px">ANSWER EXPLANATION</div>
            <div class="t-status" id="answer-status"></div>
            <div style="margin:20px 0; padding:15px; background:rgba(0,0,0,0.5); border:1px solid #444; border-radius:5px;">
                <div style="color:#ffd700; font-weight:bold; margin-bottom:10px;">CORRECT ANSWER:</div>
                <div id="correct-answer" style="color:#fff; font-size:18px; margin-bottom:15px;"></div>
                <div style="color:#00ffaa; font-weight:bold; margin-bottom:10px;">EXPLANATION:</div>
                <div id="answer-explanation" style="color:#ccc; line-height:1.5;"></div>
            </div>
            <button class="menu-btn" onclick="continueFromExplanation()">CONTINUE</button>
        </div>
    </div>

    <div id="glossary-tooltip"></div>

    <div id="upgrade-overlay" class="overlay hidden">
        <div class="modal-content">
            <h2 id="up-header" style="color:#fff; font-size:50px; margin-bottom: 10px;">SYSTEM UPGRADE</h2>
            <div class="ans-grid" id="up-container"></div>
        </div>
    </div>

</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const screens = {
    start: document.getElementById('start-screen'),
    death: document.getElementById('death-screen'),
    win: document.getElementById('win-screen'),
    settings: document.getElementById('settings-screen'),
    hud: document.getElementById('hud'),
    upgrade: document.getElementById('upgrade-overlay'),
    trivia: document.getElementById('trivia-overlay'),
    answerExplanation: document.getElementById('answer-explanation-overlay'),
    pause: document.getElementById('pause-screen'),
    learn: document.getElementById('learn-screen'),
    tutorial: document.getElementById('tutorial-screen'),
    depth: document.getElementById('depth-screen'),
    zoneIntro: document.getElementById('zone-intro')
};

// Simple Code for Dev Menu Unlock (4-1)
const DEV_CODE_SEQUENCE = ['4', '1'];
let devCodeIndex = 0;
let devMenuUnlocked = false;

function showDevNotification(message, color) {
    // Create or update notification element
    let notification = document.getElementById('dev-notification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'dev-notification';
        notification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: ${color};
            font-size: 16px;
            font-weight: bold;
            z-index: 10000;
            pointer-events: none;
            transition: opacity 0.3s;
        `;
        document.body.appendChild(notification);
    }
    
    notification.textContent = message;
    notification.style.color = color;
    notification.style.opacity = '1';
    
    // Fade out after 3 seconds
    setTimeout(() => {
        notification.style.opacity = '0';
    }, 3000);
}

function checkDevCode(key) {
    if (key === DEV_CODE_SEQUENCE[devCodeIndex]) {
        devCodeIndex++;
        if (devCodeIndex === DEV_CODE_SEQUENCE.length) {
            devMenuUnlocked = !devMenuUnlocked; // Toggle on/off
            devCodeIndex = 0;
            
            if (devMenuUnlocked) {
                showDevNotification("DEV MENU UNLOCKED!", "#ff00de");
            } else {
                showDevNotification("DEV MENU LOCKED!", "#ff2a6d");
                // Hide dev console if it's open
                const console = document.getElementById('dev-console');
                if (console.style.display === 'block') {
                    console.style.display = 'none';
                }
            }
        }
    } else {
        devCodeIndex = 0;
    }
}

// CONSTANTS
const ROOM_WIDTH = 2400; // Large Arena
const ROOM_HEIGHT = 1800;
const WAVES_PER_DEPTH = 10;
const MAX_PARTICLES = 200; // Increased for better coverage
const SNOW_PARTICLES = []; // Separate array for snow particles
const MAX_XP = 300; // Performance Cap
const MAX_ENEMIES = 100; // Performance cap for enemies

const DEPTH_NAMES = [
    "ZONE OF ACCUMULATION",
    "EQUILIBRIUM LINE",
    "CREVASSES",
    "LANDFORMS & CIRQUE",
    "ZONE OF ABLATION", 
    "MORAINE DEPOSITS"
];

// Zone descriptions for educational intros
const ZONE_DESCRIPTIONS = [
    `The <span style="color:#00f2fe">Zone of Accumulation</span> is where snowfall exceeds melting. Fresh snow compresses into firn - intermediate-stage ice formed by pressure - and eventually glacial ice through pressure. This zone is characterized by positive mass balance and serves as the glacier's "fuel tank." The snowline marks the boundary between accumulation and ablation zones. Over decades, this compaction process transforms fluffy snow into dense blue ice that can flow under its own weight, creating the massive ice rivers we call glaciers. 
    
    <span style="color:#ff9900">Climate Impact:</span> Rising temperatures are pushing the snowline to higher altitudes, shrinking accumulation zones worldwide. This reduces the glacier's "fuel tank" and threatens long-term ice survival. Many glaciers now have accumulation zones too small to sustain their mass, leading to inevitable retreat.`,
    
    `The <span style="color:#00f2fe">Equilibrium Line</span> represents the altitude where accumulation equals ablation annually. Below this line, the glacier loses mass; above it, gains mass. This dynamic balance point fluctuates with climate conditions and is critical for predicting glacier health and behavior. Scientists track this line carefully because its movement up or down indicates whether a glacier is growing or shrinking in response to climate change.
    
    <span style="color:#ff9900">Climate Impact:</span> The equilibrium line is rising globally as temperatures warm. When it rises above the glacier's highest point, the entire glacier enters the ablation zone and begins irreversible retreat. This upward migration is one of the clearest indicators of climate change impacts on ice systems.`,
    
    `<span style="color:#00f2fe">Crevasses</span> are deep fractures in glacial ice caused by tensile stress - pulling forces that stretch and crack the ice. They form when ice moves over uneven terrain or changes velocity. Despite appearances, crevasses rarely extend beyond 50 meters deep due to plastic ice flow under pressure. They're navigation hazards but important for studying internal glacier structure. Glaciologists use crevasse patterns to understand ice flow dynamics and stress distribution within the glacier.
    
    <span style="color:#ff9900">Climate Impact:</span> Warmer temperatures increase meltwater production, which can both lubricate glacier beds (increasing flow and crevasse formation) and cause surface collapse. More variable flow patterns create complex crevasse networks that make glacier travel increasingly dangerous.`,
    
    `Glacial <span style="color:#00f2fe">Landforms</span> like cirques, aretes, and horns result from erosional processes. A cirque is an amphitheater-shaped basin carved by ice accumulation and rotational sliding. When multiple cirques converge, they create distinctive sharp ridges and pyramidal peaks that define alpine landscapes. These features reveal the powerful erosive force of glaciers as they grind away rock like massive sheets of sandpaper, shaping mountains over thousands of years.
    
    <span style="color:#ff9900">Climate Impact:</span> As glaciers retreat, they expose newly carved landscapes that haven't seen sunlight for thousands of years. This creates new ecosystems but also destabilizes slopes, increasing rockfall and landslide risks in recently deglaciated areas.`,
    
    `The <span style="color:#00f2fe">Zone of Ablation</span> is where ice loss exceeds accumulation through melting, sublimation - direct ice-to-vapor transition, and calving - ice breaking off into water. Ablation processes include surface melt from solar radiation, basal melt from geothermal heat, and frontal ablation at glacier termini. This zone determines a glacier's net mass balance and retreat rate. The balance between accumulation and ablation zones ultimately controls whether glaciers advance, retreat, or remain stable.
    
    <span style="color:#ff9900">Climate Impact:</span> Ablation zones are expanding dramatically worldwide. Longer melt seasons, reduced snow cover, and higher temperatures are accelerating ice loss. This expansion contributes to sea level rise and threatens freshwater supplies for downstream communities.`,
    
    `<span style="color:#00f2fe">Moraines</span> are accumulations of glacially transported debris. Terminal moraines mark maximum ice extent, lateral moraines form along glacier edges, and medial moraines result from merging glaciers. These deposits preserve climate history and influence post-glacial ecosystems. Each moraine tells a story about the glacier's past extent and the types of rock it encountered during its journey.
    
    <span style="color:#ff9900">Climate Impact:</span> Modern glaciers are retreating past ancient moraines, revealing landscapes not seen in over 11,000 years since the last ice age. This retreat is creating new lakes behind unstable moraine dams, posing flood risks to downstream communities.`
];

// STATE
let gameState="MENU", previousState="MENU"; 
let gameStartTime = 0;
let gameEndTime = 0;

let gameSettings = { 
    bloom: false, 
    fps: false,
    mouseType: 'crosshair'
};
let animationFrameId, transitionTimer;
let keys = { w:false, a:false, s:false, d:false, space:false, q:false, e:false, arrowUp:false, arrowDown:false, arrowLeft:false, arrowRight:false };
let mouse = { x: 0, y: 0, wx: 0, wy: 0, down: false };
let camera = { x: 0, y: 0 };
let screenShake = 0;

// GAME VARIABLES
let depthIndex = 0; 
let wave = 0; 
let waveSpawnScheduled = false; // Prevents spam-skip from queuing multiple spawns
let player = {};
let bullets=[], enemies=[], particles=[], xpOrbs=[], floatTexts=[], visuals=[];
let portal = { active: false, x: 0, y: 0, r: 80, angle: 0 };
let spawnTimer = 0;
let askedQuestions = []; 
let triviaAnswered = false;
let triviaLocked = false; // NEW: Prevent multiple answer clicks
let nextLevelIsModule = false; // When true, next level-up shows module pick (after wrong on module level)
let introKeysHeldWhenShown = {}; // Keys that were held when zone intro appeared; continue only on different key or click
let currentTriviaQuestion = null; // Store current question for explanation screen

// TIME & FPS
let lastTime = 0;
let gameTime = 0; // ms, for enemy contact cooldown
let fpsTimer = 0;
let frames = 0;
let aimMode = 'mouse'; // 'mouse' or 'keys'; switch only when user uses that input
let aimModeLockUntil = 0; // After overlay close, ignore mousemove for a moment so arrow-key aim isn't overridden

const glossary = {
    "accumulation": "Where snowfall adds more mass to a glacier than is lost; the upper zone where snow turns into firn and ice.",
    "ablation": "Processes that remove mass from a glacier (melting, sublimation, calving).",
    "equilibrium line": "The boundary altitude where annual accumulation equals annual ablation; above it the glacier gains mass, below it it loses mass.",
    "firn": "Old, compacted snow that has survived at least one melt season; an intermediate stage between snow and glacial ice.",
    "albedo": "How reflective a surface is. Higher albedo reflects more sunlight and reduces melting.",
    "basal friction": "Resistance between the glacier base and the bed. Lower basal friction can speed up glacier flow.",
    "meltwater": "Water produced by melting snow/ice. When it reaches the base, it can lubricate the bed and increase sliding.",
    "basal sliding": "Glacier motion caused by the ice sliding over the bed, often enhanced by meltwater.",
    "crevasses": "Deep cracks in glacier ice formed by stress when the ice stretches or moves over uneven terrain.",
    "tensile stress": "Pulling stress that stretches a material; in glaciers it commonly creates crevasses.",
    "plastic": "When ice deforms and flows rather than breaking; at depth, pressure makes ice behave more plastically.",
    "calving": "Breaking off of chunks of ice from a glacier terminus into water, forming icebergs.",
    "sublimation": "Ice turning directly into water vapor without melting.",
    "terminus": "The end (snout) of a glacier.",
    "moraines": "Ridges or piles of debris (sediment/rock) transported and deposited by glaciers.",
    "cirque": "A bowl-shaped hollow carved into a mountain by glacial erosion, often where glaciers form.",
    "aretes": "Sharp ridges formed when glaciers erode on both sides of a mountain ridge.",
    "horns": "Sharp, pyramid-like peaks formed when several cirques erode a mountain from multiple sides."
};

const glossaryTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);
const glossaryRegex = new RegExp(`\\b(${glossaryTerms.map(t => t.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')).join('|')})\\b`, 'gi');

const GENERAL_ARCHIVE_BLURB = `<p><span style="color:#00f2fe">How Glaciers Work:</span> Glaciers are massive rivers of ice that form when snow accumulates over many years and compresses into ice. They flow slowly downhill under their own weight, like very thick honey. Glaciers grow when more snow falls than melts, and shrink when melting exceeds snowfall.</p>

<p><span style="color:#00f2fe">Glacier Movement:</span> Ice moves in two main ways. The ice itself deforms and flows internally, especially under pressure. The glacier can also slide over its bed if there's meltwater lubricating the bottom. This combination creates the slow but steady movement we see in glaciers.</p>

<p><span style="color:#00f2fe">Seasonal Changes:</span> Glaciers have seasons just like weather. In winter, they gain snow and grow. In summer, they melt and shrink. The key is whether they gain more than they lose over the entire year. This yearly balance determines if a glacier is healthy or shrinking.</p>

<p><span style="color:#00f2fe">Reading the Ice:</span> Scientists can read glacier history like a book. The equilibrium line shows where melting equals accumulation. Crevasses reveal stress patterns. Moraines are piles of debris that mark where glaciers once reached. Each feature tells part of the glacier's story.</p>

<p><span style="color:#ff9900">Climate Change Connection:</span> Rising global temperatures are disrupting the natural balance of glaciers worldwide. Warmer air means more melting and less snow accumulation. This causes glaciers to retreat, contributing to sea level rise and threatening water supplies for millions of people who depend on glacial meltwater.</p>

<p><span style="color:#00f2fe">Why It Matters:</span> Glaciers are like water towers, storing winter snow and releasing it slowly during summer. They provide drinking water, irrigation, and hydroelectric power. As glaciers disappear, rivers may flood in spring then run dry in summer, creating serious challenges for communities and ecosystems.</p>`;

function applyGlossaryToElement(el) {
    if (!el) return;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);

    nodes.forEach(node => {
        const text = node.nodeValue;
        if (!text) return;
        glossaryRegex.lastIndex = 0;
        if (!glossaryRegex.test(text)) return;
        glossaryRegex.lastIndex = 0;

        const frag = document.createDocumentFragment();
        let last = 0;
        text.replace(glossaryRegex, (match, _term, offset) => {
            if (offset > last) frag.appendChild(document.createTextNode(text.slice(last, offset)));
            const span = document.createElement('span');
            span.className = 'gloss-term';
            span.dataset.term = match.toLowerCase();
            span.textContent = match;
            frag.appendChild(span);
            last = offset + match.length;
        });
        if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
        node.parentNode.replaceChild(frag, node);
    });
}

const glossaryTooltip = document.getElementById('glossary-tooltip');
let glossaryTooltipActive = false;

function positionGlossaryTooltip(e) {
    if (!glossaryTooltipActive) return;
    const pad = 12;
    const margin = 16;
    let x = e.clientX + margin;
    let y = e.clientY + margin;
    const w = glossaryTooltip.offsetWidth;
    const h = glossaryTooltip.offsetHeight;
    if (x + w + pad > window.innerWidth) x = e.clientX - w - margin;
    if (y + h + pad > window.innerHeight) y = e.clientY - h - margin;
    glossaryTooltip.style.left = Math.max(pad, x) + 'px';
    glossaryTooltip.style.top = Math.max(pad, y) + 'px';
}

document.addEventListener('mouseover', (e) => {
    const termEl = e.target && e.target.closest ? e.target.closest('.gloss-term') : null;
    if (!termEl) return;
    const key = (termEl.dataset.term || '').toLowerCase();
    const def = glossary[key];
    if (!def) return;
    glossaryTooltip.innerHTML = `<div class="gt-title">${termEl.textContent}</div><div class="gt-body">${def}</div>`;
    glossaryTooltip.classList.add('show');
    glossaryTooltipActive = true;
    positionGlossaryTooltip(e);
});

document.addEventListener('mousemove', (e) => { positionGlossaryTooltip(e); });

document.addEventListener('mouseout', (e) => {
    const leavingTerm = e.target && e.target.closest ? e.target.closest('.gloss-term') : null;
    if (!leavingTerm) return;
    const to = e.relatedTarget;
    if (to && to.closest && to.closest('.gloss-term')) return;
    glossaryTooltip.classList.remove('show');
    glossaryTooltipActive = false;
});

/* --- DATA --- */
const abilitiesDB = [
    { id: 'shock', name: 'Shockwave', desc: 'Press SPACE to blast nearby enemies away.', color: '#00f2fe' },
    { id: 'mag', name: 'Gravity Well', desc: 'Press Q to pull XP orbs toward you.', color: '#fff' },
    { id: 'multi', name: 'Multi-Shot', desc: 'Press E to fire three shots at once.', color: '#ff9900' },
    { id: 'shield', name: 'Energy Shield', desc: 'Blocks one hit, then recharges.', color: '#00ffaa' }
];

// SIMPLE UPGRADES WITH CLEAR NAMES AND DESCRIPTIONS
const upgradesDB = [
    { n: "Faster Shooting", d: "Shoot 15% faster", apply: p=>{ p.fr=Math.max(3, p.fr*0.85); }, undo: p=>{ p.fr/=0.85; } },
    { n: "More Damage", d: "Bullets do 25% more damage", apply: p=>{ p.dmg*=1.25; }, undo: p=>{ p.dmg/=1.25; } },
    { n: "More Health", d: "Max health +30 and heal fully", apply: p=>{ p.maxHp+=30; p.hp=p.maxHp; }, undo: p=>{ p.maxHp-=30; if(p.hp>p.maxHp)p.hp=p.maxHp; } },
    { n: "Faster Movement", d: "Move 10% faster", apply: p=>{ p.spd*=1.1; }, undo: p=>{ p.spd/=1.1; } },
    { n: "Faster Bullets", d: "Bullets move 20% faster", apply: p=>{ p.bulletSpd*=1.2; }, undo: p=>{ p.bulletSpd/=1.2; } },
    // Conditional
    { req: 'shock', n: "Stronger Shockwave", d: "Shockwave damage +50", apply: p=>{ p.blastDmg+=50; }, undo: p=>{ p.blastDmg-=50; } },
    { req: 'shock', n: "Faster Shockwave", d: "Shockwave cooldown 20% faster", apply: p=>p.shockMax*=0.8, undo: p=>p.shockMax/=0.8 },
    { req: 'shock', n: "Bigger Shockwave", d: "Shockwave radius 25% bigger", apply: p=>p.shockRad*=1.25, undo: p=>p.shockRad/=1.25 },
    { req: 'mag', n: "Faster Gravity", d: "Gravity Well cooldown 20% faster", apply: p=>p.magMax*=0.8, undo: p=>p.magMax/=0.8 },
    { req: 'shield', n: "Faster Shield", d: "Shield recharges 20% faster", apply: p=>p.shieldMax*=0.8, undo: p=>p.shieldMax/=0.8 },
    { req: 'multi', n: "Longer Multi-Shot", d: "Multi-Shot lasts 1 second longer", apply: p=>p.multiDur+=60, undo: p=>p.multiDur-=60 },
    { req: 'multi', n: "Faster Multi-Shot", d: "Multi-Shot cooldown 20% faster", apply: p=>p.multiMax*=0.8, undo: p=>p.multiMax/=0.8 }
];

// IMPROVED TRIVIA QUESTIONS WITH BETTER FORMATTING
const triviaQuestions = [
    {
        id: 1,
        q: "A glacier begins flowing faster each year despite no increase in temperature. What is the most likely explanation?",
        a: ["Basal friction has decreased due to meltwater lubrication"],
        d: [
            "Ice crystals have grown larger from pressure",
            "Snow density in the accumulation zone increased",
            "Surface albedo has significantly increased"
        ],
        explanation: "When meltwater reaches the glacier bed, it acts as a lubricant, reducing basal friction and allowing the glacier to slide faster. This is a primary mechanism for glacier acceleration and can occur even without temperature changes if meltwater production increases due to other factors like rainfall or reduced surface albedo.",
        tags: ["general"]
    },
    {
        id: 2,
        q: "Two glaciers receive equal snowfall, but one grows while the other shrinks. What must be different between them?",
        a: ["Their total ablation rate differs significantly"],
        d: [
            "The color of their ice varies",
            "Their crevasse patterns are different",
            "The thickness of their firn layers"
        ],
        explanation: "Glacier mass balance depends on the difference between accumulation (snowfall) and ablation (melting, sublimation, calving). Even with equal snowfall, differences in ablation due to factors like temperature, solar radiation exposure, altitude, or debris cover can cause one glacier to grow while another shrinks.",
        tags: ["general"]
    },
    {
        id: 3,
        q: "Which observation best indicates a glacier's accumulation zone has expanded?",
        a: ["The equilibrium line has moved downslope to a lower elevation"],
        d: [
            "Crevasses have widened near the terminus",
            "The glacier has begun calving icebergs",
            "Surface debris has thickened significantly"
        ],
        explanation: "The equilibrium line marks the boundary between accumulation (where snowfall exceeds melting) and ablation zones. When this line moves downslope to lower elevations, it means a larger area of the glacier is experiencing net mass gain, indicating an expanded accumulation zone.",
        tags: ["accum"]
    },
    {
        id: 4,
        q: "After several consecutive colder summers, what change would appear FIRST in the accumulation zone?",
        a: ["Greater thickness of the firn layer"],
        d: [
            "Increased basal sliding velocity",
            "More extensive terminal moraine growth",
            "Deeper crevasse formation"
        ],
        explanation: "Firn is intermediate-stage snow that has survived at least one melt season. During colder summers, less melting occurs, allowing more snow to accumulate and compress into firn. This happens before other effects like increased flow velocity or moraine growth, which take longer to develop.",
        tags: ["accum"]
    },
    {
        id: 5,
        q: "A glacier's equilibrium line rises for multiple consecutive years. What long-term trend should follow?",
        a: ["Net mass loss increases as the ablation zone expands"],
        d: [
            "Basal temperatures drop significantly",
            "Ice flow velocity reaches its maximum",
            "Moraine sediment becomes better sorted"
        ],
        explanation: "When the equilibrium line rises, it means the area where accumulation equals ablation is moving upslope. This indicates that a larger portion of the glacier is experiencing net melting (ablation zone expansion), leading to increased overall mass loss and glacier retreat over time.",
        tags: ["eq"]
    },
    {
        id: 6,
        q: "What condition could keep a glacier stable despite unusually warm summers?",
        a: ["Exceptionally high winter snowfall"],
        d: [
            "Thick surface debris insulating the ice",
            "Exceptionally low ice density",
            "Very steep valley walls"
        ],
        explanation: "Glacier stability depends on the balance between accumulation and ablation. Even with warm summers causing high melting, exceptionally high winter snowfall can compensate by adding enough mass to maintain equilibrium. This demonstrates how increased precipitation can offset temperature effects.",
        tags: ["eq"]
    },
    {
        id: 7,
        q: "A glacier enters a significantly steeper valley section. What surface change is most likely?",
        a: ["Increased crevasse formation due to tensile stress"],
        d: [
            "Ice becomes more transparent and blue",
            "Overall flow velocity decreases",
            "Firn compacts into ice more rapidly"
        ],
        explanation: "When ice flows over steeper terrain, it accelerates and experiences tensile stress (pulling forces). This stress stretches and cracks the ice, forming crevasses. Steeper slopes increase flow velocity and stress, making crevasse formation more likely and extensive.",
        tags: ["crev"]
    },
    {
        id: 8,
        q: "Why do crevasses rarely extend more than 50 meters deep into glacier ice?",
        a: ["Ice flows plastically under pressure at depth"],
        d: [
            "Meltwater refreezes and seals the cracks",
            "Temperature increases with depth, making ice ductile",
            "Rock debris naturally fills the fractures"
        ],
        explanation: "At depths below about 50 meters, the overlying ice pressure is sufficient to make ice behave plastically (like a very thick fluid) rather than brittle. This plastic flow allows the ice to deform and close fractures rather than maintaining open cracks, limiting crevasse depth.",
        tags: ["crev"]
    },
    {
        id: 9,
        q: "Which landscape feature provides the STRONGEST evidence of long-term glacial erosion?",
        a: ["A classic U-shaped valley with steep sides"],
        d: [
            "A V-shaped river valley",
            "A braided river system",
            "A broad floodplain"
        ],
        explanation: "U-shaped valleys are distinctive landforms created by glacial erosion, where wide, steep-sided valleys replace the original V-shaped river valleys. This transformation requires thousands of years of ice flow and is definitive evidence of long-term glacial activity, unlike other features that can form through non-glacial processes.",
        tags: ["land"]
    },
    {
        id: 10,
        q: "Two cirques continue eroding backward toward each other. What landform typically remains between them?",
        a: ["A sharp, narrow ridge called an arête"],
        d: [
            "A flat-bottomed basin",
            "A debris fan formation",
            "A meltwater channel network"
        ],
        explanation: "When cirques (bowl-shaped basins carved by glaciers) erode backward from opposite sides of a mountain ridge, they leave a sharp, narrow ridge between them. This ridge is called an arête and is a classic glacial erosional feature formed by the headward erosion of adjacent glaciers.",
        tags: ["land"]
    },
    {
        id: 11,
        q: "A glacier loses mass despite air temperatures staying below freezing. Which process explains this?",
        a: ["Sublimation - direct ice-to-vapor transition"],
        d: [
            "Surface melting from solar radiation",
            "Basal freezing adding ice at the bottom",
            "Firn compaction reducing volume"
        ],
        explanation: "Sublimation is the process where ice transforms directly into water vapor without melting first. This can occur even in below-freezing temperatures, especially in dry, windy conditions or under intense solar radiation. It's a significant ablation process that can cause mass loss without any melting.",
        tags: ["abl"]
    },
    {
        id: 12,
        q: "Which factor most strongly increases glacier ablation rates?",
        a: ["Longer duration of the melt season"],
        d: [
            "Higher snow albedo (reflectivity)",
            "Steeper slopes in accumulation zone",
            "Lower overall ice density"
        ],
        explanation: "The duration of the melt season is the most critical factor for ablation because it determines how long melting conditions persist. A longer melt season means more days with temperatures above freezing, more solar radiation exposure, and more time for melting, sublimation, and other ablation processes to occur.",
        tags: ["abl"]
    },
    {
        id: 13,
        q: "Glacial debris contains unsorted mixture of boulders and clay in same layer. What does this indicate?",
        a: ["Direct transport by ice without water sorting"],
        d: [
            "Sorting by meltwater streams",
            "Wind deposition and sorting",
            "Multiple freeze-thaw cycles"
        ],
        explanation: "Glaciers transport sediment of all sizes together, from fine clay to house-sized boulders, without sorting by size. This unsorted mixture (called till) is characteristic of direct ice deposition. In contrast, water and wind typically sort sediments by size and density, creating layered deposits.",
        tags: ["mor"]
    },
    {
        id: 14,
        q: "A retreating glacier leaves a large ridge of debris parallel to its former flow. What does this ridge mark?",
        a: ["A former stable terminus position (terminal moraine)"],
        d: [
            "The equilibrium line position",
            "The zone of maximum flow velocity",
            "The accumulation zone maximum"
        ],
        explanation: "Terminal moraines form at a glacier's terminus when the ice margin remains stable for an extended period, allowing debris to accumulate in a ridge. When the glacier retreats, this ridge marks the furthest extent of the ice, providing a record of the glacier's maximum position.",
        tags: ["mor"]
    },
    {
        id: 15,
        q: "How much has global sea level risen due to glacier melt since 1990?",
        a: ["Approximately 2 centimeters per decade"],
        d: [
            "Less than 0.5 centimeters per decade",
            "Over 5 centimeters per decade",
            "Sea level has actually decreased"
        ],
        explanation: "Since 1990, glaciers and ice caps have contributed roughly 2 centimeters per decade to global sea level rise. While this may seem small, it represents a massive volume of ice melt and is accelerating as global temperatures continue to rise.",
        tags: ["general"]
    },
    {
        id: 16,
        q: "What percentage of the world's population depends on glacial meltwater for freshwater?",
        a: ["About 15-20% (roughly 1.5 billion people)"],
        d: [
            "Less than 5%",
            "About 50%",
            "Nearly 80%"
        ],
        explanation: "Approximately 1.5 billion people, or 15-20% of the global population, rely on glacial meltwater for drinking water, agriculture, and hydroelectric power. Major river systems in Asia (Indus, Ganges, Brahmaputra) depend heavily on Himalayan glaciers.",
        tags: ["general"]
    },
    {
        id: 17,
        q: "What is the primary cause of accelerated glacier retreat in the 21st century?",
        a: ["Rising global air temperatures"],
        d: [
            "Increased volcanic activity",
            "Changes in Earth's orbit",
            "Reduced snowfall precipitation"
        ],
        explanation: "The primary driver of accelerated glacier retreat is rising global air temperatures due to greenhouse gas emissions. While other factors like precipitation changes play a role, temperature increase is the dominant factor causing more melting and reduced accumulation.",
        tags: ["general"]
    },
    {
        id: 18,
        q: "Which region has lost the most glacier ice mass since 2000?",
        a: ["Alaska and surrounding regions"],
        d: [
            "The European Alps",
            "Greenland ice sheet",
            "Himalayan glaciers"
        ],
        explanation: "Alaska has experienced the largest mass loss of any glacier region, losing over 75 gigatons of ice annually. This is due to its location in a warming Arctic where temperatures are rising faster than the global average.",
        tags: ["general"]
    }
];
 
/* --- NAVIGATION --- */
function hideAll() { Object.values(screens).forEach(s => s.classList.add('hidden')); }
function goBackFromArchive() {
    if(previousState === 'MENU') {
        hideAll();
        screens.start.classList.remove('hidden');
        gameState = "MENU";
        renderBackground();
    } else if(previousState === 'PAUSE') {
        screens.learn.classList.add('hidden');
        screens.pause.classList.remove('hidden');
        gameState = "PAUSE";
        updatePauseStats();
    } else if(previousState === 'PLAY') {
        hideAll();
        screens.hud.classList.remove('hidden');
        gameState = "PLAY";
    } else {
        // Default to main menu if state is unclear
        hideAll();
        screens.start.classList.remove('hidden');
        gameState = "MENU";
        renderBackground();
    }
    updateCanvasCursor();
}

function goHome() { 
    if(transitionTimer) clearTimeout(transitionTimer);
    gameState="MENU"; hideAll(); screens.start.classList.remove('hidden'); 
    updateCanvasCursor();
    renderBackground(); 
}

function showLearn() {
    previousState = gameState; // Remember where we came from
    if(previousState === 'PAUSE') {
        screens.pause.classList.add('hidden');
        screens.learn.classList.remove('hidden');
    } else {
        hideAll();
        screens.learn.classList.remove('hidden');
    }
    renderArchive();
}

function showTutorial() {
    hideAll();
    screens.tutorial.classList.remove('hidden');
    startTutorialAnimation();
}

function closeTutorial() {
    screens.tutorial.classList.add('hidden');
    screens.start.classList.remove('hidden');
    stopTutorialAnimation();
}

let tutorialAnimation = null;

function startTutorialAnimation() {
    const canvas = document.getElementById('tutorial-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let time = 0;
    
    const player = { x: 40, y: 100, aimAngle: 0 };
    const bullets = [];
    let shotCount = 0;
    
    function animate() {
        ctx.fillStyle = '#020205';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw actual player sprite
        ctx.save(); 
        ctx.translate(player.x, player.y); 
        ctx.rotate(player.aimAngle);
        ctx.fillStyle = "#000"; 
        ctx.strokeStyle = "#fff"; 
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10; 
        ctx.shadowColor = "#00f2fe";
        ctx.beginPath(); 
        ctx.moveTo(15, 0); 
        ctx.lineTo(-12, 12); 
        ctx.lineTo(-6, 0); 
        ctx.lineTo(-12, -12); 
        ctx.closePath();
        ctx.fill(); 
        ctx.stroke(); 
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // Shoot bullets every 20 frames
        if (time % 20 === 0) {
            shotCount++;
            const isPierce = shotCount % 4 === 0;
            bullets.push({
                x: player.x + Math.cos(player.aimAngle) * 20,
                y: player.y + Math.sin(player.aimAngle) * 20,
                vx: Math.cos(player.aimAngle) * 4,
                vy: Math.sin(player.aimAngle) * 4,
                pierce: isPierce
            });
        }
        
        // Update and draw bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            bullet.x += bullet.vx;
            bullet.y += bullet.vy;
            
            ctx.fillStyle = bullet.pierce ? '#fff' : '#00f2fe';
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Remove bullets that go off screen
            if (bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                bullets.splice(i, 1);
            }
        }
        
        time++;
        tutorialAnimation = requestAnimationFrame(animate);
    }
    
    animate();
}

function stopTutorialAnimation() {
    if (tutorialAnimation) {
        cancelAnimationFrame(tutorialAnimation);
        tutorialAnimation = null;
    }
}

function renderArchive() {
    const container = document.getElementById('archive-container');
    if (!container) return;

    const zoneTags = ['accum', 'eq', 'crev', 'land', 'abl', 'mor'];

    const sections = [];
    for (let i = 0; i < DEPTH_NAMES.length; i++) {
        const tag = zoneTags[i];
        const zoneTitle = `ZONE ${i + 1}: ${DEPTH_NAMES[i]}`;
        const desc = ZONE_DESCRIPTIONS[i] || "";
        sections.push(`
            <div class="archive-section">
                <div class="archive-section-title">${zoneTitle}</div>
                <div class="archive-section-body">${desc}</div>
            </div>
        `);
    }

    // Climate Change Section
    sections.push(`
        <div class="archive-section">
            <div class="archive-section-title">CLIMATE CHANGE IMPACTS</div>
            <div class="archive-section-body">
                <p><span style="color:#ff9900">Rising Temperatures:</span> Global warming is causing glaciers to melt faster than they can accumulate new snow. This imbalance is causing glaciers worldwide to shrink and retreat.</p>
                
                <p><span style="color:#ff9900">Sea Level Rise:</span> As glaciers melt, water flows into oceans, causing sea levels to rise. This threatens coastal communities and ecosystems around the world.</p>
                
                <p><span style="color:#ff9900">Water Scarcity:</span> Over 1.5 billion people depend on glacial meltwater for drinking water, farming, and electricity. As glaciers disappear, these communities face water shortages.</p>
                
                <p><span style="color:#ff9900">Natural Hazards:</span> Retreating glaciers create unstable lakes behind moraine dams. These can burst suddenly, causing devastating floods in mountain valleys.</p>
                
                <p><span style="color:#ff9900">Ecosystem Changes:</span> Glacial retreat exposes land that hasn't seen sunlight for thousands of years, creating new habitats but also disrupting existing ecosystems.</p>
                
                <p><span style="color:#ff9900">What We Can Do:</span> Reducing greenhouse gas emissions, protecting glacier environments, and monitoring changes can help slow glacier loss and prepare communities for impacts.</p>
            </div>
        </div>
    `);

    sections.push(`
        <div class="archive-section">
            <div class="archive-section-title">GENERAL KNOWLEDGE</div>
            <div class="archive-section-body">${GENERAL_ARCHIVE_BLURB}</div>
        </div>
    `);

    container.innerHTML = sections.join('');
    applyGlossaryToElement(container);
}

function switchArchiveTab(tabName) {
    renderArchive();
}

function openSettings(fromState) {
    previousState = fromState === 'MENU' ? 'MENU' : gameState;
    if(gameState === 'PLAY') gameState = 'PAUSE'; 
    hideAll();
    screens.settings.classList.remove('hidden');
    
    // Update UI to reflect current settings
    updateMouseTypeUI();
    if (typeof updateZoomPreview === 'function') updateZoomPreview(gameSettings.zoomLevel);
    document.getElementById('btn-bloom').innerText = gameSettings.bloom ? "EFFECTS: HIGH" : "EFFECTS: LOW";
}

function closeSettings() {
    hideAll();
    if(previousState === 'MENU') {
        screens.start.classList.remove('hidden');
        gameState = "MENU";
    } else {
        screens.pause.classList.remove('hidden');
        screens.hud.classList.remove('hidden');
        gameState = "PAUSE";
    }
}

function applyCanvasResolution() {
    canvas.width = 1920;
    canvas.height = 1080;
    if (gameState === "MENU") renderBackground();
}

function toggleBloom() {
    gameSettings.bloom = !gameSettings.bloom;
    document.getElementById('btn-bloom').innerText = gameSettings.bloom ? "EFFECTS: HIGH" : "EFFECTS: LOW";
}

function toggleFps() {
    gameSettings.fps = !gameSettings.fps;
    document.getElementById('btn-fps').innerText = gameSettings.fps ? "FPS: ON" : "FPS: OFF";
    document.getElementById('fps-counter').style.display = gameSettings.fps ? 'block' : 'none';
}
 
function changeMouseType(type) {
    gameSettings.mouseType = type;
    updateMouseTypeUI();
    updateCanvasCursor();
}

function updateMouseTypeUI() {
    document.querySelectorAll('.mouse-option').forEach(option => {
        option.classList.remove('active');
    });
    document.querySelector(`[onclick="changeMouseType('${gameSettings.mouseType}')"]`).classList.add('active');
}

function updateCanvasCursor() {
    switch(gameSettings.mouseType) {
        case 'crosshair':
            canvas.style.cursor = "crosshair";
            break;
        case 'pointer':
            canvas.style.cursor = "pointer";
            break;
        case 'circle':
            canvas.style.cursor = "none";
            break;
    }
}

function startGame() { 
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    if(transitionTimer) clearTimeout(transitionTimer);
    hideAll(); screens.hud.classList.remove('hidden'); 
    updateCanvasCursor();
    
    depthIndex = 0;
    gameTime = 0;
    gameStartTime = Date.now(); // Start timing
    aimMode = 'mouse';
    nextLevelIsModule = false;
    resetPlayer();
    showZoneIntro(); // Show intro instead of directly starting
    
    lastTime = performance.now();
    loop(lastTime); 
}

function showZoneIntro() {
    gameState = "INTRO";
    screens.zoneIntro.classList.remove('hidden');
    
    // Pre-simulate snow during the intro
    // Clear existing snow
    SNOW_PARTICLES.length = 0;
    
    // Pre-populate with snow throughout the screen
    for (let i = 0; i < 100; i++) {
        createSnowfallParticle(Math.random() * ROOM_HEIGHT, true);
    }
    
    // Simulate a few seconds of snowfall
    const simTime = 3; // seconds
    const steps = 60 * simTime; // 60fps * seconds
    const dt = 1000/60; // 60fps in ms
    
    for (let i = 0; i < steps; i++) {
        updateSnowParticles(dt);
    }
    
    // Remember which keys were held so we only continue on a *different* key or after release
    introKeysHeldWhenShown = {
        w: keys.w, a: keys.a, s: keys.s, d: keys.d, space: keys.space,
        arrowUp: keys.arrowUp, arrowDown: keys.arrowDown, arrowLeft: keys.arrowLeft, arrowRight: keys.arrowRight
    };
    
    document.getElementById('zone-title').textContent = DEPTH_NAMES[depthIndex];
    document.getElementById('zone-description').innerHTML = buildZoneBrief(depthIndex);
    applyGlossaryToElement(document.getElementById('zone-description'));
    document.getElementById('zone-continue').textContent = "Press any key to continue...";
    
    document.addEventListener('keydown', handleIntroContinue);
    canvas.addEventListener('click', handleIntroContinue);
}

function buildZoneBrief(idx) {
    const zoneTags = ['accum', 'eq', 'crev', 'land', 'abl', 'mor'];
    const tag = zoneTags[idx];

    const pool = triviaQuestions.filter(q => q.tags && (q.tags.includes('general') || (tag && q.tags.includes(tag))));
    const answers = [...new Set(pool.map(q => (q.a && q.a[0]) ? q.a[0] : '').filter(Boolean))];

    const toSentence = (s) => {
        const t = (s || '').trim();
        if (!t) return '';
        return /[.!?]$/.test(t) ? t : (t + '.');
    };

    const base = (ZONE_DESCRIPTIONS[idx] || '').trim();
    const basePara = base ? `<p>${base}</p>` : '';

    if (answers.length === 0) return basePara;

    return basePara;
}

function handleIntroContinue(e) {
    if (gameState !== "INTRO") return;
    
    // Click always counts as "new" action - continue
    if (e.type === 'click') {
        document.removeEventListener('keydown', handleIntroContinue);
        canvas.removeEventListener('click', handleIntroContinue);
        screens.zoneIntro.classList.add('hidden');
        startDepth();
        return;
    }
    
    // Keydown: only continue if this key was NOT already held when the intro appeared
    // (so they must press a different key, or release and press again)
    if (e.type === 'keydown') {
        if (e.code === 'Space') e.preventDefault();
        const codeToKey = { 'KeyW':'w','KeyA':'a','KeyS':'s','KeyD':'d','Space':'space','ArrowUp':'arrowUp','ArrowDown':'arrowDown','ArrowLeft':'arrowLeft','ArrowRight':'arrowRight' };
        const keyName = codeToKey[e.code];
        // Check if this key was initially held AND is still currently held
        if (keyName && introKeysHeldWhenShown[keyName] && keys[keyName]) return; // still the same key held - ignore until they release or press another key
    }
    
    document.removeEventListener('keydown', handleIntroContinue);
    canvas.removeEventListener('click', handleIntroContinue);
    screens.zoneIntro.classList.add('hidden');
    startDepth();
}

function resetPlayer() {
    player = {
        x: ROOM_WIDTH/2, y: ROOM_HEIGHT/2,
        hp: 100, maxHp: 100, xp: 0, req: 50, lvl: 1,
        spd: 7, dmg: 30, fr: 18, cd: 0, bulletSpd: 16,
        shotCount: 0, blastDmg: 200, 
        upgradeHistory: [],
        hasShock: false, shockMax: 600, shockTimer: 600, shockRad: 450, 
        hasMag: false, magMax: 1000, magTimer: 1000, magDur: 150, magActive: 0,
        hasMulti: false, multiMax: 900, multiTimer: 900, multiDur: 120, multiActive: 0,
        hasShield: false, shieldMax: 800, shieldTimer: 800, shieldUp: false
    };
    askedQuestions = [];
    updateHUD(); updateSkillUI();
    // Update Dev Console Values
    document.getElementById('dev-dmg').value = player.dmg;
    document.getElementById('dev-fr').value = player.fr;
    document.getElementById('dev-spd').value = player.spd;
    document.getElementById('dev-bspd').value = player.bulletSpd;
}

function togglePause() {
    if(gameState === "PLAY") {
        gameState = "PAUSE";
        screens.pause.classList.remove('hidden');
        updatePauseStats();
    } else if(gameState === "PAUSE") {
        gameState = "PLAY";
        screens.pause.classList.add('hidden');
        lastTime = performance.now(); // Reset time to avoid jump
    }
}

function updatePauseStats() {
    document.getElementById('st-dmg').innerText = Math.floor(player.dmg);
    document.getElementById('st-fr').innerText = (60/player.fr).toFixed(1) + "/s";
    document.getElementById('st-spd').innerText = player.spd.toFixed(1);
    document.getElementById('st-hp').innerText = Math.floor(player.maxHp);
    
    let m = document.getElementById('st-mods');
    m.innerHTML = "";
    if(!player.hasShock && !player.hasMag && !player.hasShield && !player.hasMulti) m.innerHTML = "<span style='color:#666'>No Modules Installed</span>";
    if(player.hasShock) m.innerHTML += "<div class='stat-row' style='color:#00f2fe'>Shockwave</div>";
    if(player.hasMag) m.innerHTML += "<div class='stat-row' style='color:#fff'>Gravity Well</div>";
    if(player.hasMulti) m.innerHTML += "<div class='stat-row' style='color:#ff9900'>Multi-Shot</div>";
    if(player.hasShield) m.innerHTML += "<div class='stat-row' style='color:#00ffaa'>Energy Shield</div>";
}

/* --- GAME LOGIC --- */
function startDepth() {
    // Show Transition
    gameState = "TRANSITION";
    portal.active = false; // Reset portal
    screens.depth.classList.remove('hidden');
    document.getElementById('depth-title').innerText = DEPTH_NAMES[depthIndex];
    document.getElementById('depth-sub').innerText = `DEPTH ${depthIndex + 1}`;
    
    transitionTimer = setTimeout(() => {
        screens.depth.classList.add('hidden');
        gameState = "PLAY";
        lastTime = performance.now(); // Reset Delta
        wave = 0;
        bullets = []; enemies = []; particles = []; visuals = []; xpOrbs = [];
        player.x = ROOM_WIDTH/2; player.y = ROOM_HEIGHT/2;
        document.getElementById('level-tag').innerText = DEPTH_NAMES[depthIndex];
        spawnNextWave();
    }, 2000);
}

function spawnNextWave() {
    // GUARD CLAUSE: Don't spawn if portal is active or already at max wave
    if(portal.active) return;
    if(wave >= WAVES_PER_DEPTH) return;
    
    waveSpawnScheduled = false;
    wave++;
    document.getElementById('wave-tag').innerText = `WAVE ${wave}/${WAVES_PER_DEPTH}`;
    addFloat(`WAVE ${wave}`, player.x, player.y - 150, "#ff9900");

    // MODERATE SPAM LOGIC: Original formula * 1.5 (50% Increase)
    let rawCount = 3 + (depthIndex * 1.8) + Math.floor(wave * 0.6);
    const count = Math.min(Math.floor(rawCount * 1.5), MAX_ENEMIES - enemies.length); // Cap by remaining slots
    
    // Don't spawn if at max capacity
    if(enemies.length >= MAX_ENEMIES) return;
    
    for(let i=0; i<count; i++) {
        // STRICTER SHAPE LOGIC:
        let maxSides = 4 + depthIndex; 
        let minSides = 3;
        let sides = minSides + Math.floor(Math.random() * (maxSides - minSides + 1));

        // HP and Speed Tweaks
        let hp = (35 + (depthIndex*10) + (wave*4)) * (1+(sides-3)*0.4);
        let spd = Math.max(1.5, 5 - (sides*0.5) + (depthIndex*0.1)); // Original speed formula
        
        let ex, ey, dist;
        do {
            ex = Math.random()*ROOM_WIDTH;
            ey = Math.random()*ROOM_HEIGHT;
            dist = Math.sqrt((ex-player.x)**2 + (ey-player.y)**2);
        } while(dist < 700); 

        const colors = ['#ff0055','#ff9900','#ffe600','#33ff00','#00ffff','#0066ff','#9900ff'];
        enemies.push({ 
            id: Math.random(),
            x:ex, y:ey, hp:hp, maxHp:hp, sides:sides, size:20+(sides*4), spd:spd, 
            color:colors[(sides-3)%7], angle:0, spin:(Math.random()-0.5)*0.15,
            type: 'normal',
            xpValue: (sides * sides) + (depthIndex * 20) // XP based on enemy stats
        });
        visuals.push({type:'spawn', x:ex, y:ey, r:60, op:1});
    }

    // SPAWN KAMIKAZES (Starting from Depth 2 or late waves of Depth 1)
    if(depthIndex >= 1 && enemies.length < MAX_ENEMIES) {
        let kamiCount = Math.min(Math.floor(wave / 3) + (depthIndex - 1), MAX_ENEMIES - enemies.length);
        // Reduce kamikaze count at high enemy counts for performance
        if(enemies.length > 60) kamiCount = Math.floor(kamiCount * 0.5);
        if(kamiCount > 0) {
            for(let k=0; k<kamiCount; k++) {
                let ex, ey, dist;
                do {
                    ex = Math.random()*ROOM_WIDTH;
                    ey = Math.random()*ROOM_HEIGHT;
                    dist = Math.sqrt((ex-player.x)**2 + (ey-player.y)**2);
                } while(dist < 900); 

                enemies.push({ 
                    id: Math.random(),
                    x:ex, y:ey, hp: 1, maxHp:1, sides:3, size:25, spd:9, // Fast
                    color: '#ff0000', angle:0, spin:0.3,
                    type: 'kamikaze',
                    xpValue: 50 + (depthIndex * 10) // Kamikazes give more XP
                });
                visuals.push({type:'spawn', x:ex, y:ey, r:60, op:1});
                addFloat("WARNING", ex, ey, "#ff0000");
            }
        }
    }
}

function checkWaveClear() {
    if(enemies.length === 0 && gameState === "PLAY") {
        if(wave >= WAVES_PER_DEPTH) {
            // PORTAL SPAWNS CENTER
            if(!portal.active) {
                portal.active = true;
                portal.x = ROOM_WIDTH / 2;
                portal.y = ROOM_HEIGHT / 2;
                addFloat("PORTAL OPEN", portal.x, portal.y - 120, "#00ffaa");
            }
        } else if(!waveSpawnScheduled) {
            waveSpawnScheduled = true;
            setTimeout(spawnNextWave, 1000); 
        }
    }
}

/* --- TRIVIA & LEVEL UP --- */
function checkLevelUp() {
    if(player.xp >= player.req) {
        player.xp = 0; player.req = Math.floor(player.req * 1.35);
        player.lvl++;
        updateHUD();
        startTrivia();
    }
}

function startTrivia() {
    triviaAnswered = false;
    triviaLocked = false; // Reset lock

    // If they got the previous question wrong on a module level, this level-up is the module
    if(nextLevelIsModule) {
        nextLevelIsModule = false;
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });
        if(unacquired.length > 0) {
            triggerUnlock(unacquired);
            return;
        }
    }

    gameState = "TRIVIA";
    screens.trivia.classList.remove('hidden');
    document.getElementById('t-status').innerText = "";
    
    // Pick Question logic
    let tag = "";
    if(depthIndex===0) tag="accum"; else if(depthIndex===1) tag="eq"; else if(depthIndex===2) tag="crev";
    else if(depthIndex===3) tag="land"; else if(depthIndex===4) tag="abl"; else if(depthIndex===5) tag="mor";
    
    // Filter available questions not asked yet
    let pool = triviaQuestions.filter(q => !askedQuestions.includes(q.id) && (q.tags.includes("general") || q.tags.includes(tag)));
    // If ran out, reset pool for this tag
    if(pool.length === 0) {
        pool = triviaQuestions.filter(q => q.tags.includes("general") || q.tags.includes(tag));
    }
    
    let q = pool[Math.floor(Math.random()*pool.length)];
    askedQuestions.push(q.id);
    currentTriviaQuestion = q; // Store current question for explanation screen

    // Format question with line breaks for readability
    let formattedQ = q.q;
    // Add line breaks after commas or periods when question is long
    if (q.q.length > 80) {
        formattedQ = q.q.replace(/([,.])\s+(?=\w)/g, '$1<br>');
    }
    
    document.getElementById('t-ques').innerHTML = formattedQ;
    applyGlossaryToElement(document.getElementById('t-ques'));

    // Answers
    let correct = q.a[0];
    let opts = [correct, ...q.d];
    opts.sort(() => Math.random() - 0.5);

    const box = document.getElementById('t-opts'); 
    box.innerHTML = "";
    
    opts.forEach(o => {
        let btn = document.createElement('button');
        btn.className = "t-btn";
        btn.innerHTML = `<span class="t-btn-text">${o}</span>`;
        applyGlossaryToElement(btn.querySelector('.t-btn-text'));
        btn.onclick = () => {
            if (!triviaLocked) {
                triviaLocked = true; // Lock answers
                checkAnswer(o === correct, btn);
            }
        };
        box.appendChild(btn);
    });
}

function checkAnswer(isCorrect, clickedBtn) {
    triviaAnswered = true;
    
    // Disable all answer buttons
    document.querySelectorAll('.t-btn').forEach(btn => {
        btn.classList.add('disabled');
        btn.style.pointerEvents = 'none';
    });
    
    if(isCorrect) {
        document.getElementById('t-status').innerText = "CORRECT";
        document.getElementById('t-status').style.color = "#00ffaa";
        clickedBtn.style.backgroundColor = "#00ffaa";
        clickedBtn.style.color = "#000";
        clickedBtn.style.borderColor = "#00ffaa";
    } else {
        document.getElementById('t-status').innerText = "INCORRECT";
        document.getElementById('t-status').style.color = "#ff2a6d";
        clickedBtn.style.backgroundColor = "#ff2a6d";
        clickedBtn.style.color = "#000";
        clickedBtn.style.borderColor = "#ff2a6d";
        shake(10);
        // Wrong on a level that would have been module (every 4 levels): next level-up = module
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });
        if(player.lvl % 4 === 0 && unacquired.length > 0) nextLevelIsModule = true;
    }

    // Show explanation screen after a short delay
    setTimeout(() => {
        showAnswerExplanation(isCorrect);
    }, 1500);
}

function showAnswerExplanation(isCorrect) {
    if (!currentTriviaQuestion) return;
    
    // Pause the game
    gameState = "EXPLANATION";
    
    // Hide trivia screen and show explanation screen
    screens.trivia.classList.add('hidden');
    screens.answerExplanation.classList.remove('hidden');
    
    // Set status
    const statusEl = document.getElementById('answer-status');
    if (isCorrect) {
        statusEl.innerText = "CORRECT!";
        statusEl.style.color = "#00ffaa";
    } else {
        statusEl.innerText = "INCORRECT";
        statusEl.style.color = "#ff2a6d";
    }
    
    // Set correct answer
    const correctAnswerEl = document.getElementById('correct-answer');
    correctAnswerEl.innerText = currentTriviaQuestion.a[0];
    
    // Set explanation
    const explanationEl = document.getElementById('answer-explanation');
    explanationEl.innerText = currentTriviaQuestion.explanation;
    
    // Apply glossary to explanation content
    applyGlossaryToElement(correctAnswerEl);
    applyGlossaryToElement(explanationEl);
}

function continueFromExplanation() {
    screens.answerExplanation.classList.add('hidden');
    
    // Continue with the appropriate flow based on whether answer was correct
    const wasCorrect = document.getElementById('answer-status').innerText === "CORRECT!";
    
    if (wasCorrect) {
        // Check for Module Unlock every 4 levels
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });

        if(player.lvl % 4 === 0 && unacquired.length > 0) triggerUnlock(unacquired);
        else triggerUpgrade();
    } else {
        // Wrong answer - return to game
        aimModeLockUntil = Date.now() + 250; // Preserve arrow-key aim when exiting trivia
        gameState = "PLAY";
        lastTime = performance.now(); // Reset time to avoid physics jump
    }
}

function triggerUnlock(availableAbs) {
    gameState="UPGRADE"; screens.upgrade.classList.remove('hidden');
    document.getElementById('up-header').innerText = "NEW MODULE";
    document.getElementById('up-header').style.color = "#ff00de";
    const con = document.getElementById('up-container'); con.innerHTML="";
    availableAbs.forEach(a => {
        const div = document.createElement('div'); div.className='upgrade-btn unlock-btn';
        div.innerHTML=`<div class="u-tag">NEW ABILITY</div><div class="u-title">${a.name}</div><div class="u-desc">${a.desc}</div>`;
        div.onclick = () => {
            if(a.id==='shock') player.hasShock=true;
            if(a.id==='mag') player.hasMag=true;
            if(a.id==='multi') player.hasMulti=true;
            if(a.id==='shield') { player.hasShield=true; player.shieldUp=true; }
            finishLevelUp(null);
        };
        con.appendChild(div);
    });
}

function triggerUpgrade() {
    gameState="UPGRADE"; screens.upgrade.classList.remove('hidden');
    document.getElementById('up-header').innerText = "LEVEL UP";
    document.getElementById('up-header').style.color = "#fff";
    const con = document.getElementById('up-container'); con.innerHTML="";
    
    // 1. Force More Health upgrade
    const healthUpgrade = upgradesDB.find(u => u.n === "More Health");

    // 2. Get pool of others
    let pool = upgradesDB.filter(u => {
        if(u.n === "More Health") return false; 
        if(u.req === 'shock' && !player.hasShock) return false;
        if(u.req === 'mag' && !player.hasMag) return false;
        if(u.req === 'multi' && !player.hasMulti) return false;
        if(u.req === 'shield' && !player.hasShield) return false;
        return true;
    });

    // 3. Select 3 randoms + Health upgrade
    let selected = pool.sort(()=>Math.random()-0.5).slice(0,3);
    selected.push(healthUpgrade);
    
    // 4. Shuffle again for display
    selected.sort(()=>Math.random()-0.5);

    selected.forEach(u => {
        const div = document.createElement('div'); div.className='upgrade-btn';
        div.innerHTML=`<div class="u-tag">UPGRADE</div><div class="u-title">${u.n}</div><div class="u-desc">${u.d}</div>`;
        div.onclick = () => { u.apply(player); finishLevelUp(u); };
        con.appendChild(div);
    });
}

function finishLevelUp(upObj) { 
    if(upObj) player.upgradeHistory.push(upObj); 
    aimModeLockUntil = Date.now() + 250; // Preserve arrow-key aim when exiting upgrade
    updateHUD(); updateSkillUI(); screens.upgrade.classList.add('hidden'); gameState="PLAY"; 
    lastTime = performance.now(); // Reset time
    // Sync Dev Console
    document.getElementById('dev-dmg').value = player.dmg;
    document.getElementById('dev-fr').value = player.fr;
    document.getElementById('dev-spd').value = player.spd;
}

/* --- UPDATES --- */
function updateHUD() {
    document.getElementById('hp-fill').style.width = Math.max(0, (player.hp/player.maxHp*100)) + "%";
    document.getElementById('xp-fill').style.width = (player.xp/player.req*100) + "%";
    document.getElementById('lvl-txt').innerText = player.lvl;
}

function updateSkillUI() {
    const u = (id, has, timer, max, active) => {
        const box = document.getElementById('skill-'+id);
        const cd = document.getElementById('cd-'+id);
        if(has) {
            box.style.display="flex";
            let pct = 1 - (timer/max);
            if(active > 0) pct = 0; 
            cd.style.height = (pct*100)+"%";
            const ready = (timer >= max && active <= 0);
            if(ready) box.classList.add('ready'); else box.classList.remove('ready');
            if(!ready) box.classList.add('cooling'); else box.classList.remove('cooling');
        } else box.style.display="none";
    };
    u('shock', player.hasShock, player.shockTimer, player.shockMax, 0);
    u('mag', player.hasMag, player.magTimer, player.magMax, player.magActive);
    u('multi', player.hasMulti, player.multiTimer, player.multiMax, player.multiActive);
    
    const shBox = document.getElementById('skill-shield');
    if(player.hasShield) {
        shBox.style.display="flex";
        if(player.shieldUp) { shBox.classList.add('ready'); shBox.classList.remove('cooling'); document.getElementById('cd-shield').style.height="0%"; }
        else { shBox.classList.remove('ready'); shBox.classList.add('cooling'); document.getElementById('cd-shield').style.height=(player.shieldTimer/player.shieldMax*100)+"%"; }
    } else shBox.style.display="none";
}

function shake(amt) { screenShake=amt; }
function addFloat(t,x,y,c) { if(floatTexts.length>20)floatTexts.shift(); floatTexts.push({t,x,y,c,l:60}); }
function getDistSq(x1, y1, x2, y2) { return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2); }

let viewBounds = null; // Set each frame in drawRoom; avoids repeated camera/canvas reads
function isOnScreen(obj) {
    if (!viewBounds) return true;
    return (obj.x >= viewBounds.left && obj.x <= viewBounds.right &&
            obj.y >= viewBounds.top && obj.y <= viewBounds.bottom);
}

/* --- MAIN LOOP --- */
function loop(timestamp) {
    const isIdle = (gameState === "MENU" || gameState === "WIN" || gameState === "INTRO");
    if (!isIdle) animationFrameId = requestAnimationFrame(loop);
    else animationFrameId = setTimeout(() => requestAnimationFrame(loop), 100);
    
    // FPS Calculation
    if(!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Normalization: 1.0 at 60 FPS
    let dt = Math.min(deltaTime / 16.666, 4); 

    fpsTimer += deltaTime;
    frames++;
    if(fpsTimer >= 500) {
        document.getElementById('fps-counter').innerText = "FPS: " + Math.round((frames * 1000) / fpsTimer);
        frames = 0;
        fpsTimer = 0;
    }

    // DEV TOOL HOOK: UPDATE LOOP
    if(window.devUpdate) window.devUpdate();
    
    if(gameState === "MENU" || gameState === "WIN" || gameState === "INTRO" || gameState === "EXPLANATION") { 
        renderBackground(); 
        if (gameSettings.mouseType === 'circle' && (gameState === "INTRO" || gameState === "MENU" || gameState === "EXPLANATION")) {
            drawCustomCursor();
        }
        return; 
    }
    if(gameState !== "PLAY" && gameState !== "UPGRADE") return; // PAUSE EVERYTHING EXCEPT UPGRADE
    
    update(dt);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); applyCamera(); drawRoom(); ctx.restore();
    
    // Draw custom cursor if needed
    if (gameSettings.mouseType === 'circle') {
        drawCustomCursor();
    }
}

function drawCustomCursor() {
    ctx.save();
    ctx.translate(mouse.x, mouse.y);
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, TAU);
    ctx.stroke();
    ctx.restore();
}

function applyCamera() {
    let targetX = player.x - canvas.width/2;
    let targetY = player.y - canvas.height/2;
    let sx=(Math.random()-0.5)*screenShake, sy=(Math.random()-0.5)*screenShake;
    if(screenShake>0) screenShake*=0.9;
    camera.x += (targetX - camera.x)*0.1;
    camera.y += (targetY - camera.y)*0.1;
    
    // Apply zoom scaling
    ctx.translate(-camera.x+sx, -camera.y+sy);
}

function createSnowfallParticle(initialY = -20, randomY = false) {
    if (SNOW_PARTICLES.length >= MAX_PARTICLES) return;
    
    // Calculate spawn area within room bounds
    const x = 20 + Math.random() * (ROOM_WIDTH - 40);
    // If randomY is true, spawn anywhere from top to bottom of screen
    const y = randomY ? Math.random() * ROOM_HEIGHT : (initialY || -20);
    
    SNOW_PARTICLES.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5, // Slower side-to-side drift
        vy: Math.random() * 0.8 + 0.5,   // Slower downward speed
        c: 'rgba(255, 255, 255, 0.7)',   // Slightly transparent
        s: Math.random() * 2 + 1,        // Varying size
        // No lifetime - snow stays until it hits bottom or goes off screen
    });
}

function updateSnowParticles(dt) {
    // Always update snow particles, even when not in Zone 1
    for (let i = SNOW_PARTICLES.length - 1; i >= 0; i--) {
        const p = SNOW_PARTICLES[i];
        
        // Update position
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        
        // Bounce off walls
        if (p.x < 20) { p.x = 20; p.vx *= -0.5; }
        if (p.x > ROOM_WIDTH - 20) { p.x = ROOM_WIDTH - 20; p.vx *= -0.5; }
        
        // Remove if below bottom of screen
        if (p.y > ROOM_HEIGHT) {
            SNOW_PARTICLES.splice(i, 1);
        }
    }
    
    // Add new snow particles
    // Create a more consistent flow of snow (2-3 particles per frame)
    const snowPerFrame = 2 + Math.random();
    for (let i = 0; i < snowPerFrame; i++) {
        if (Math.random() < 0.5) { // 50% chance to spawn a new flake each frame
            createSnowfallParticle();
        }
    }
}

// Performance optimizations
const TARGET_FPS = 60;
const FRAME_TIME = 1000 / TARGET_FPS;
let lastFrameTime = 0;
let frameSkipCounter = 0;

// Reduce update frequency for distant objects
const UPDATE_EVERY_N_FRAMES = 2; // Update distant enemies every 2 frames

// Dynamic quality scaling
let qualityLevel = 1; // 1 = high, 0.5 = medium, 0.25 = low

function updateQualityLevel() {
    if(enemies.length > 80) qualityLevel = 0.25;
    else if(enemies.length > 50) qualityLevel = 0.5;
    else qualityLevel = 1;
}
const particlePool = [];
let particlePoolIndex = 0;

function getParticle() {
    if (particlePool.length < MAX_PARTICLES) {
        return null; // Create new particle if pool not full
    }
    const particle = particlePool[particlePoolIndex];
    particlePoolIndex = (particlePoolIndex + 1) % MAX_PARTICLES;
    return particle;
}

function addParticleToPool(particle) {
    if (particlePool.length < MAX_PARTICLES) {
        particlePool.push(particle);
    }
}

// Spatial grid for collision optimization
const GRID_SIZE = 100;
let spatialGrid = {};

function clearSpatialGrid() {
    spatialGrid = {};
}

function getGridKey(x, y) {
    const gridX = Math.floor(x / GRID_SIZE);
    const gridY = Math.floor(y / GRID_SIZE);
    return `${gridX},${gridY}`;
}

function addToGrid(obj, type) {
    const key = getGridKey(obj.x, obj.y);
    if (!spatialGrid[key]) spatialGrid[key] = [];
    spatialGrid[key].push({ obj, type });
}

function getNearbyObjects(x, y, radius) {
    const nearby = [];
    const gridRadius = Math.ceil(radius / GRID_SIZE);
    const centerKey = getGridKey(x, y);
    const [centerX, centerY] = centerKey.split(',').map(Number);
    
    for (let gx = centerX - gridRadius; gx <= centerX + gridRadius; gx++) {
        for (let gy = centerY - gridRadius; gy <= centerY + gridRadius; gy++) {
            const key = `${gx},${gy}`;
            if (spatialGrid[key]) {
                nearby.push(...spatialGrid[key]);
            }
        }
    }
    return nearby;
}

function update(dt) {
    // Update frame counter for optimizations
    frameSkipCounter = (frameSkipCounter + 1) % UPDATE_EVERY_N_FRAMES;
    
    // Update quality based on enemy count
    updateQualityLevel();
    
    // Always update snow particles (even in menus for visual effect)
    updateSnowParticles(dt);
    
    // Pause game if not in PLAY state (allow UPGRADE to update)
    if(gameState !== "PLAY" && gameState !== "UPGRADE") return;
    
    mouse.wx = mouse.x + camera.x; mouse.wy = mouse.y + camera.y;

    // Movement (Scaled by DT) - Only allow movement in PLAY state
    if(gameState === "PLAY") {
        if(keys.w) player.y-=player.spd * dt;
        if(keys.s) player.y+=player.spd * dt;
        if(keys.a) player.x-=player.spd * dt;
        if(keys.d) player.x+=player.spd * dt;
        if(player.x < 30) player.x = 30; if(player.x > ROOM_WIDTH-30) player.x = ROOM_WIDTH-30;
        if(player.y < 30) player.y = 30; if(player.y > ROOM_HEIGHT-30) player.y = ROOM_HEIGHT-30;
    }

    // PORTAL INTERACTION
    if(portal.active) {
        portal.angle += 0.02 * dt;
        if(getDistSq(player.x, player.y, portal.x, portal.y) < (portal.r/2 + 30)**2) {
            // Enter portal
            portal.active = false;
            depthIndex++;
            if(depthIndex >= DEPTH_NAMES.length) {
                // WIN CONDITION
                gameState = "WIN";
                gameEndTime = Date.now();
                const totalTime = Math.floor((gameEndTime - gameStartTime) / 1000);
                const minutes = Math.floor(totalTime / 60);
                const seconds = totalTime % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                hideAll();
                screens.win.classList.remove('hidden');
                document.getElementById('win-time').innerText = `Time: ${timeString}`;
            } else {
                showZoneIntro(); // Always show intro for next zone
            }
            return;
        }
    }

    // Skills
    if(player.hasShock) {
        if(player.shockTimer < player.shockMax) player.shockTimer += dt;
        if(keys.space && player.shockTimer >= player.shockMax) {
            player.shockTimer = 0; shake(30);
            visuals.push({type:'shock', x:player.x, y:player.y, r:0, maxR:player.shockRad, op:1});
            const shockRad = player.shockRad;
            const rSq = shockRad * shockRad;
            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                if (Math.abs(e.x - player.x) > shockRad || Math.abs(e.y - player.y) > shockRad) continue;
                if(getDistSq(e.x, e.y, player.x, player.y) < rSq) {
                    e.hp -= player.blastDmg;
                    addFloat(Math.floor(player.blastDmg), e.x, e.y, "#00f2fe"); 
                    let a=Math.atan2(e.y-player.y, e.x-player.x);
                    // Pushback scaled by DT isn't necessary for impulse, but consistent force
                    e.x+=Math.cos(a)*350; e.y+=Math.sin(a)*350;
                    
                    // Clamp enemy position to map bounds
                    e.x = Math.max(20, Math.min(ROOM_WIDTH - 20, e.x));
                    e.y = Math.max(20, Math.min(ROOM_HEIGHT - 20, e.y)); 
                    
                    // Kill check immediately
                    if(e.hp <= 0) {
                        killEnemy(e, i); // XP Drop restored
                        checkWaveClear();
                    }
                }
            }
        }
    }
    if(player.hasMag) {
        if(player.magActive > 0) player.magActive -= dt;
        else if(player.magTimer < player.magMax) player.magTimer += dt;
        if(keys.q && player.magTimer >= player.magMax && player.magActive <= 0) {
            player.magTimer = 0; player.magActive = player.magDur; 
            addFloat("MAGNET", player.x, player.y-50, "#fff");
        }
    }
    if(player.hasMulti) {
        if(player.multiActive > 0) player.multiActive -= dt;
        else if(player.multiTimer < player.multiMax) player.multiTimer += dt;
        if(keys.e && player.multiTimer >= player.multiMax && player.multiActive <= 0) {
            player.multiTimer = 0; player.multiActive = player.multiDur;
            addFloat("MULTI-SHOT", player.x, player.y-50, "#ff9900");
        }
    }
    if(player.hasShield && !player.shieldUp) {
        player.shieldTimer -= dt;
        if(player.shieldTimer<=0) { player.shieldUp=true; player.shieldTimer=player.shieldMax; addFloat("SHIELD RECHARGED", player.x, player.y-50, "#00ffaa"); }
    }
    updateSkillUI();

    // Aim: toggle between mouse and arrow keys; don't snap to mouse until mouse is moved
    const arrowHeld = keys.arrowUp || keys.arrowDown || keys.arrowLeft || keys.arrowRight;
    if (arrowHeld) {
        aimMode = 'keys';
        const dy = (keys.arrowDown ? 1 : 0) - (keys.arrowUp ? 1 : 0);
        const dx = (keys.arrowRight ? 1 : 0) - (keys.arrowLeft ? 1 : 0);
        if (dx !== 0 || dy !== 0) player.aimAngle = Math.atan2(dy, dx);
    } else if (aimMode === 'mouse') {
        player.aimAngle = Math.atan2(mouse.wy - player.y, mouse.wx - player.x);
    }
    // else aimMode === 'keys' and no arrow held: keep current player.aimAngle

    // Shooting
    if(player.cd>0) player.cd -= dt;
    else {
        player.shotCount++;
        let isPierce = (player.shotCount % 4 === 0) || (player.multiActive > 0);
        
        // Base Shot (use player.aimAngle)
        bullets.push({
            x:player.x, y:player.y, vx:Math.cos(player.aimAngle)*player.bulletSpd, vy:Math.sin(player.aimAngle)*player.bulletSpd,
            pierce: isPierce, hitList: [] 
        });

        // Multi-Shot Logic
        if(player.multiActive > 0) {
            let spread = 0.2; // roughly 12 degrees
            bullets.push({
                x:player.x, y:player.y, vx:Math.cos(player.aimAngle+spread)*player.bulletSpd, vy:Math.sin(player.aimAngle+spread)*player.bulletSpd,
                pierce: isPierce, hitList: [] 
            });
            bullets.push({
                x:player.x, y:player.y, vx:Math.cos(player.aimAngle-spread)*player.bulletSpd, vy:Math.sin(player.aimAngle-spread)*player.bulletSpd,
                pierce: isPierce, hitList: [] 
            });
        }

        player.cd=player.fr;
    }

    // Bullets (collect indices to remove, splice once after loop)
    const bulletsToRemove = [];
    
    // Build spatial grid for this frame
    clearSpatialGrid();
    bullets.forEach(b => addToGrid(b, 'bullet'));
    enemies.forEach(e => addToGrid(e, 'enemy'));
    
    bullets.forEach((b,i)=>{
        b.x += b.vx * dt; 
        b.y += b.vy * dt;
        if(b.x<0||b.x>ROOM_WIDTH||b.y<0||b.y>ROOM_HEIGHT) { bulletsToRemove.push(i); return; }
        
        // Only check nearby enemies using spatial grid
        const nearbyEnemies = getNearbyObjects(b.x, b.y, 50).filter(item => item.type === 'enemy');
        
        for(let item of nearbyEnemies) {
            let e = item.obj;
            // Skip if enemy has immunity
            if(e.immunity > 0) continue;
            const hitRad = e.size + 15;
            if (Math.abs(e.x - b.x) > hitRad || Math.abs(e.y - b.y) > hitRad) continue;
            if(getDistSq(e.x, e.y, b.x, b.y) < hitRad * hitRad) {
                if(b.pierce && b.hitList.includes(e.id)) continue;
                e.hp-=player.dmg; 
                addFloat(Math.floor(player.dmg), e.x, e.y, b.pierce?"#00f2fe":"#fff");
                particles.push({x:b.x, y:b.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, l:10, c:'#fff'});
                if(b.pierce) b.hitList.push(e.id); else bulletsToRemove.push(i);
                if(e.hp<=0) { killEnemy(e, enemies.indexOf(e)); checkWaveClear(); }
                if(!b.pierce) break; 
            }
        }
    });
    bulletsToRemove.sort((a,b)=>b-a);
    for(let idx of bulletsToRemove) bullets.splice(idx, 1);

    // Enemies
    enemies.forEach((e, index)=>{
        // Always update movement for consistent speed, but skip expensive updates for distant enemies
        const distToPlayer = Math.sqrt((e.x - player.x)**2 + (e.y - player.y)**2);
        const shouldUpdateExpensive = (distToPlayer < 500) || (frameSkipCounter % UPDATE_EVERY_N_FRAMES === 0);
        
        // Always update movement and immunity
        if(e.immunity !== undefined) {
            e.immunity -= dt;
            if(e.immunity < 0) e.immunity = 0;
        }
        
        let a = Math.atan2(player.y-e.y, player.x-e.x);
        e.x += Math.cos(a)*e.spd * dt; 
        e.y += Math.sin(a)*e.spd * dt; 
        e.angle += e.spin * dt;
        if(e.x<e.size) e.x=e.size; if(e.x>ROOM_WIDTH-e.size) e.x=ROOM_WIDTH-e.size;
        if(e.y<e.size) e.y=e.size; if(e.y>ROOM_HEIGHT-e.size) e.y=ROOM_HEIGHT-e.size;

        // Only update expensive visual effects for nearby enemies
        if(shouldUpdateExpensive) {
            // Kamikaze Flash (reduced frequency for performance)
            if(e.type === 'kamikaze') {
                // Only flash every 200ms instead of 100ms
                e.color = (Math.floor(Date.now() / 200) % 2 === 0) ? '#ff0000' : '#ffffff';
            }
        }

        if(getDistSq(e.x, e.y, player.x, player.y) < (e.size+20)**2) {
            // GOD MODE CHECK
            const isGod = document.getElementById('dev-god').checked;
            if(isGod) {
                if(e.type === 'kamikaze') {
                    visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:100, op:1});
                    enemies.splice(index, 1);
                    addFloat("BLOCKED", player.x, player.y, "#00ffaa");
                }
                return;
            }

            // ION SHIELD LOGIC
            if(player.hasShield && player.shieldUp) {
                player.shieldUp = false;
                shake(15);
                visuals.push({type:'shieldBreak', x:player.x, y:player.y, r:60, op:1});
                
                // Push enemy back significantly
                let pushA = Math.atan2(e.y-player.y, e.x-player.x);
                e.x += Math.cos(pushA) * 300; 
                e.y += Math.sin(pushA) * 300;
                
                // Clamp enemy position to map bounds
                e.x = Math.max(20, Math.min(ROOM_WIDTH - 20, e.x));
                e.y = Math.max(20, Math.min(ROOM_HEIGHT - 20, e.y));

                // KAMIKAZE SPECIFIC: If it hit the shield, it explodes safely (or dies)
                if(e.type === 'kamikaze') {
                    // Reduced explosion effect for performance
                    if(qualityLevel > 0.5) {
                        visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:50, op:1});
                    }
                    enemies.splice(index, 1); // Die
                    addFloat("BLOCKED", player.x, player.y, "#00ffaa");
                }
                return; // NO DAMAGE TO PLAYER
            }

            // DAMAGE LOGIC (No Shield)
            if(e.type === 'kamikaze') {
                let dmg = Math.ceil(player.maxHp / 3);
                player.hp -= dmg;
                shake(30);
                // Reduced explosion effect for performance
                if(qualityLevel > 0.5) {
                    visuals.push({type:'shock', x:e.x, y:e.y, r:0, maxR:75, op:1});
                }
                enemies.splice(index, 1);
                addFloat(`-${dmg}`, player.x, player.y, "#ff0000");
                updateHUD();
                if(player.hp<=0) { 
                    gameState="DEAD"; 
                    gameEndTime = Date.now();
                    const totalTime = Math.floor((gameEndTime - gameStartTime) / 1000);
                    const minutes = Math.floor(totalTime / 60);
                    const seconds = totalTime % 60;
                    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    hideAll(); screens.death.classList.remove('hidden'); 
                    document.getElementById('final-score').innerText = `ENDED IN ${DEPTH_NAMES[depthIndex]} - WAVE ${wave}`; 
                    document.getElementById('death-time').innerText = `Time: ${timeString}`;
                }
            } else {
                // Non-kamikaze: nerfed to 1 damage per 0.5s contact (not per frame)
                if (!e.lastHitPlayerAt || gameTime - e.lastHitPlayerAt > 500) {
                    e.lastHitPlayerAt = gameTime;
                    player.hp -= 1;
                    updateHUD();
                }
                if(player.hp<=0) { 
                    gameState="DEAD"; 
                    gameEndTime = Date.now();
                    const totalTime = Math.floor((gameEndTime - gameStartTime) / 1000);
                    const minutes = Math.floor(totalTime / 60);
                    const seconds = totalTime % 60;
                    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    hideAll(); screens.death.classList.remove('hidden'); 
                    document.getElementById('final-score').innerText = `ENDED IN ${DEPTH_NAMES[depthIndex]} - WAVE ${wave}`; 
                    document.getElementById('death-time').innerText = `Time: ${timeString}`;
                }
            }
        }
    });

    // XP (collect indices to remove, splice once after loop)
    if(xpOrbs.length > MAX_XP) xpOrbs.shift(); // Hard Cap
    const xpToRemove = [];
    xpOrbs.forEach((x,i)=>{
        let dSq = getDistSq(player.x, player.y, x.x, x.y);
        let pull = (player.hasMag && player.magActive>0);
        
        let ang = Math.atan2(player.y - x.y, player.x - x.x);

        if(pull) {
            x.vx += Math.cos(ang) * 1.5 * dt; 
            x.vy += Math.sin(ang) * 1.5 * dt;
            x.vx *= 0.92; x.vy *= 0.92;
            x.x += x.vx * dt; x.y += x.vy * dt;
        } else if (dSq < 60000) { 
            let speed = 2.5 * dt; 
            x.x += Math.cos(ang) * speed * 5; 
            x.y += Math.sin(ang) * speed * 5;
        }

        if(dSq<900) { 
            player.xp+=x.v; xpToRemove.push(i);
            if(gameState !== "DEAD") { checkLevelUp(); updateHUD(); }
        }
    });
    xpToRemove.sort((a,b)=>b-a);
    for(let idx of xpToRemove) xpOrbs.splice(idx, 1);

    // Cleanup
    if(particles.length > MAX_PARTICLES) particles.shift(); // Hard Cap

    // Only update particles every other frame for performance
    if(frameSkipCounter % 2 === 0) {
        const particlesToRemove = [];
        particles.forEach((p,i)=>{
            p.l-=dt*2; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=0.3*dt;
            if(p.l<=0 || p.y>ROOM_HEIGHT) particlesToRemove.push(i);
        });
        particlesToRemove.sort((a,b)=>b-a);
        for(let idx of particlesToRemove) particles.splice(idx, 1);
    }

    const floatTextsToRemove = [];
    floatTexts.forEach((t,i)=>{ t.y -= 1 * dt; t.l -= dt; if(t.l<=0) floatTextsToRemove.push(i); });
    floatTextsToRemove.sort((a,b)=>b-a);
    for(let idx of floatTextsToRemove) floatTexts.splice(idx, 1);

    const visualsToRemove = [];
    visuals.forEach((v,i)=>{
        if(v.type==='shock') { v.r+=20 * dt; v.op-=0.04 * dt; }
        else if(v.type==='shieldBreak') { v.r+=4 * dt; v.op-=0.05 * dt; }
        else if(v.type==='spawn') { v.r-=2 * dt; v.op-=0.05 * dt; }
        if(v.op<=0 || v.r<0) visualsToRemove.push(i);
    });
    visualsToRemove.sort((a,b)=>b-a);
    for(let idx of visualsToRemove) visuals.splice(idx, 1);
}

function killEnemy(e, index) {
    enemies.splice(index,1); shake(5); 
    
    // Don't drop XP for mini enemies
    if(e.type === 'mini') {
        // Death particles in enemy color only (smaller and shorter)
        for(let k=0; k<3; k++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, l:15, c:e.color, s:2});
        return;
    }
    
    // Calculate XP value based on enemy stats
    let xpVal = e.xpValue || ((e.sides * e.sides) + (depthIndex * 20));
    
    // Create XP orbs - ALL BLUE, same size
    // Clamp enemy position to map bounds to prevent XP orbs from spawning outside
    const clampedX = Math.max(20, Math.min(ROOM_WIDTH - 20, e.x));
    const clampedY = Math.max(20, Math.min(ROOM_HEIGHT - 20, e.y));
    
    for(let i=0;i<3;i++) {
        xpOrbs.push({ 
            x:clampedX, y:clampedY, 
            vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, 
            v: xpVal / 3, // Split XP evenly across orbs
            color: "#00f2fe" // Always blue
        });
    }
    
    // Death particles in enemy color (reduced for mini enemies and quality)
    const baseParticleCount = e.type === 'mini' ? 2 : 6;
    const particleCount = Math.floor(baseParticleCount * qualityLevel);
    for(let k=0; k<particleCount; k++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, l:15, c:e.color, s:2});
    
    // Spawn mini versions for shapes with 6+ sides (50% chance)
    if(e.sides >= 6 && e.type === 'normal' && Math.random() < 0.5) {
        const miniCount = Math.floor(Math.random() * 4) + 3; // 3-6 mini versions
        const colors = ['#ff0055','#ff9900','#ffe600','#33ff00','#00ffff','#0066ff','#9900ff'];
        
        for(let i=0; i<miniCount; i++) {
            const angle = (i / miniCount) * Math.PI * 2;
            const spawnDist = 40;
            const miniX = e.x + Math.cos(angle) * spawnDist;
            const miniY = e.y + Math.sin(angle) * spawnDist;
            
            enemies.push({
                id: Math.random(),
                x: miniX,
                y: miniY,
                hp: 1, // One-hit kill
                maxHp: 1,
                sides: e.sides,
                size: e.size * 0.5, // Half the size
                spd: e.spd, // Same speed as parent
                color: colors[(e.sides-3)%7],
                angle: 0,
                spin: (Math.random()-0.5)*0.3, // More spin
                type: 'mini',
                xpValue: 0, // No XP drops
                immunity: 0.5 // 0.5 seconds of immunity to prevent immediate death from piercing shots
            });
            
            visuals.push({type:'spawn', x:miniX, y:miniY, r:30, op:1});
        }
    }
}

/* --- RENDER --- */
function renderBackground() {
    ctx.fillStyle="#020205"; ctx.fillRect(0,0,canvas.width,canvas.height);
}

const TAU = Math.PI * 2; // Reuse for arcs

function drawRoom() {
    const buffer = 100;
    viewBounds = {
        left: camera.x - buffer,
        right: camera.x + canvas.width + buffer,
        top: camera.y - buffer,
        bottom: camera.y + canvas.height + buffer
    };

    const palettes = [
        { bg: "#0a0a10", grid: "rgba(0, 242, 254, 0.05)", wall: "#00f2fe" },
        { bg: "#100a0a", grid: "rgba(255, 42, 109, 0.05)", wall: "#ff2a6d" },
        { bg: "#0a100a", grid: "rgba(0, 255, 170, 0.05)", wall: "#00ffaa" },
        { bg: "#100a10", grid: "rgba(255, 0, 222, 0.05)", wall: "#ff00de" },
        { bg: "#10100a", grid: "rgba(255, 165, 0, 0.05)", wall: "#ffa500" },
        { bg: "#0a0a0a", grid: "rgba(255, 255, 255, 0.05)", wall: "#ffffff" }
    ];
    const pal = palettes[depthIndex % palettes.length];

    ctx.fillStyle = "#020205"; ctx.fillRect(viewBounds.left, viewBounds.top, viewBounds.right - viewBounds.left, viewBounds.bottom - viewBounds.top);
    ctx.fillStyle = pal.bg; ctx.fillRect(0,0,ROOM_WIDTH, ROOM_HEIGHT);

    ctx.strokeStyle = pal.wall; ctx.lineWidth = 10;
    ctx.shadowBlur = 20; ctx.shadowColor = pal.wall; ctx.strokeRect(0,0,ROOM_WIDTH,ROOM_HEIGHT); ctx.shadowBlur = 0;

    // MAGNET LINES
    if(player.hasMag && player.magActive > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random()*0.5 + 0.2})`;
        ctx.lineWidth = 1;
        ctx.shadowBlur = 10; ctx.shadowColor = "#fff";
        ctx.beginPath();
        xpOrbs.forEach(orb => {
            if(!isOnScreen(orb)) return; // Culling
            if(getDistSq(player.x, player.y, orb.x, orb.y) < 500000) {
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(orb.x, orb.y);
            }
        });
        ctx.stroke();
        ctx.restore();
    }

    // DRAW PORTAL
    if(portal.active) {
        ctx.save(); 
        ctx.translate(portal.x, portal.y); 
        
        ctx.save();
        ctx.rotate(portal.angle);
        ctx.strokeStyle = "#00ffaa"; ctx.lineWidth = 5; ctx.shadowBlur = 20; ctx.shadowColor = "#00ffaa";
        ctx.beginPath();
        for(let i=0; i<8; i++) {
            let th = (i/8)*TAU;
            ctx[i===0?'moveTo':'lineTo'](Math.cos(th)*portal.r, Math.sin(th)*portal.r);
        }
        ctx.closePath(); ctx.stroke();
        
        ctx.globalAlpha = 0.3 + Math.sin(Date.now()/200)*0.2;
        ctx.fillStyle = "#00ffaa"; ctx.fill();
        ctx.restore(); // Restore rotation
        
        ctx.globalAlpha = 1;
        
        ctx.fillStyle = "#fff"; ctx.font="bold 16px Montserrat";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.shadowBlur = 5; ctx.shadowColor = "#000";
        ctx.fillText("ENTER", 0, 0); 

        ctx.restore(); // Restore translation
    }

    // Draw snow particles
    ctx.save();
    ctx.globalAlpha = 0.7;
    SNOW_PARTICLES.forEach(p => {
            if (p.y < camera.y + canvas.height && p.y > camera.y - 50) { // Only draw visible particles
                ctx.fillStyle = p.c;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.restore();

    // Visuals
    visuals.forEach(v => {
        if(v.type==='shock') { ctx.strokeStyle=`rgba(0,242,254,${v.op})`; ctx.lineWidth=8; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.stroke(); }
        else if(v.type==='shieldBreak') { ctx.strokeStyle=`rgba(0,255,170,${v.op})`; ctx.lineWidth=5; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.stroke(); }
        else if(v.type==='spawn') { ctx.fillStyle=`rgba(255,255,255,${v.op})`; ctx.beginPath(); ctx.arc(v.x,v.y,v.r,0,Math.PI*2); ctx.fill(); }
    });

    if(player.hasShield && player.shieldUp) {
        ctx.save(); ctx.translate(player.x, player.y);
        ctx.strokeStyle = `rgba(0, 255, 170, ${0.4 + Math.sin(Date.now()/150)*0.2})`; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, 50, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
    }

    // BLOOM ON
    const useBloom = gameSettings.bloom; 
    if(useBloom) ctx.globalCompositeOperation = 'lighter';
    
    // Draw XP Orbs - ALL BLUE, SAME SIZE (6px)
    xpOrbs.forEach(x=>{ 
        if(!isOnScreen(x)) return;
        if(useBloom) { ctx.shadowBlur=10; ctx.shadowColor= "#00f2fe"; }
        ctx.fillStyle= "#00f2fe"; 
        ctx.beginPath(); 
        ctx.arc(x.x,x.y, 6, 0,TAU); 
        ctx.fill(); 
        if(useBloom) ctx.shadowBlur=0; 
    });
    
    particles.forEach(p=>{ 
        if(!isOnScreen(p)) return;
        ctx.fillStyle=p.c; ctx.globalAlpha=p.l/30; ctx.beginPath(); ctx.arc(p.x,p.y,p.s||3,0,TAU); ctx.fill(); 
    });
    ctx.globalAlpha=1;
    
    if(useBloom) { ctx.shadowBlur = 10; }
    bullets.forEach(b=>{ 
        if(!isOnScreen(b)) return;
        ctx.fillStyle = b.pierce ? "#fff" : "#00f2fe"; 
        if(useBloom) ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(b.x,b.y,4,0,TAU); ctx.fill(); 
    });
    ctx.shadowBlur=0;

    enemies.forEach(e=>{
        if(!isOnScreen(e)) return;
        ctx.strokeStyle = e.color; ctx.lineWidth = 3; ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        if(useBloom) { ctx.shadowBlur=10; ctx.shadowColor=e.color; }
        ctx.beginPath();
        for(let i=0; i<e.sides; i++) {
            const theta = (i / e.sides) * Math.PI * 2;
            ctx[i===0?'moveTo':'lineTo'](Math.cos(theta)*e.size, Math.sin(theta)*e.size);
        }
        ctx.closePath(); ctx.stroke(); ctx.restore(); ctx.shadowBlur=0;
    });
    ctx.globalCompositeOperation = 'source-over';
    
    // Reset fillStyle to ensure XP orbs render correctly
    ctx.fillStyle = "#00f2fe";

    // Player (No dot) - use aim angle (arrow keys or mouse)
    const drawAngle = (typeof player.aimAngle === 'number') ? player.aimAngle : Math.atan2(mouse.wy - player.y, mouse.wx - player.x);
    ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(drawAngle);
    ctx.fillStyle = "#000"; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
    ctx.shadowBlur=15; ctx.shadowColor="#00f2fe";
    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-15, 15); ctx.lineTo(-8, 0); ctx.lineTo(-15, -15); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.shadowBlur=0;
    ctx.restore();

    ctx.font = "900 20px 'Montserrat'"; ctx.textAlign="center";
    floatTexts.forEach(t=>{ 
        if(!isOnScreen(t)) return;
        ctx.fillStyle=t.c; ctx.globalAlpha=t.l/60; ctx.fillText(t.t, t.x, t.y); 
    });
    ctx.globalAlpha=1;
}

window.addEventListener('resize', ()=>{ applyCanvasResolution(); });

window.addEventListener('wheel', (e) => {
    if (e.ctrlKey) e.preventDefault();
}, { passive: false });

window.addEventListener('gesturestart', (e) => { e.preventDefault(); });
window.addEventListener('gesturechange', (e) => { e.preventDefault(); });
window.addEventListener('gestureend', (e) => { e.preventDefault(); });

// FIX FOR CHROMEBOOK INPUT ISSUE
window.addEventListener('focus', () => {
    // Reset all keys to false when window regains focus
    keys = { w:false, a:false, s:false, d:false, space:false, q:false, e:false, arrowUp:false, arrowDown:false, arrowLeft:false, arrowRight:false };
});

window.addEventListener('keydown', e=>{ 
    // Check dev code (4-1)
    checkDevCode(e.key);
    
    // Prevent default for space and arrows to avoid scrolling
    if(e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'ArrowLeft' || e.code === 'ArrowRight') e.preventDefault();
    if((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=' || e.key === '-' || e.key === '0')) e.preventDefault();
    
    if(e.key==='w' || e.key==='W') keys.w=true; 
    if(e.key==='a' || e.key==='A') keys.a=true; 
    if(e.key==='s' || e.key==='S') keys.s=true; 
    if(e.key==='d' || e.key==='D') keys.d=true; 
    if(e.key===' ') { keys.space=true; } 
    if(e.key==='q' || e.key==='Q') keys.q=true; 
    if(e.key==='e' || e.key==='E') keys.e=true;
    if(e.code==='ArrowUp') keys.arrowUp=true;
    if(e.code==='ArrowDown') keys.arrowDown=true;
    if(e.code==='ArrowLeft') keys.arrowLeft=true;
    if(e.code==='ArrowRight') keys.arrowRight=true;
    
    if((e.code==='ArrowUp' || e.code==='ArrowDown' || e.code==='ArrowLeft' || e.code==='ArrowRight') && gameState === 'PLAY') {
        aimMode = 'keys';
        canvas.style.cursor = "none";
    }
    
    if(e.key==='Escape') { 
        if(!screens.settings.classList.contains('hidden')) closeSettings();
        else if(!screens.learn.classList.contains('hidden')) goBackFromArchive();
        else togglePause();
    }
    // DEV CONSOLE TOGGLE (Period) - Only works if unlocked
    if(e.key === '.' && devMenuUnlocked) {
        const console = document.getElementById('dev-console');
        console.style.display = (console.style.display === 'block') ? 'none' : 'block';
    }
});

window.addEventListener('keyup', e=>{ 
    if(e.key==='w' || e.key==='W') keys.w=false; 
    if(e.key==='a' || e.key==='A') keys.a=false; 
    if(e.key==='s' || e.key==='S') keys.s=false; 
    if(e.key==='d' || e.key==='D') keys.d=false; 
    if(e.key===' ') keys.space=false; 
    if(e.key==='q' || e.key==='Q') keys.q=false; 
    if(e.key==='e' || e.key==='E') keys.e=false;
    if(e.code==='ArrowUp') keys.arrowUp=false;
    if(e.code==='ArrowDown') keys.arrowDown=false;
    if(e.code==='ArrowLeft') keys.arrowLeft=false;
    if(e.code==='ArrowRight') keys.arrowRight=false;
});

window.addEventListener('mousemove', e=>{ 
    const rect = canvas.getBoundingClientRect();
    const scale = Math.min(rect.width / canvas.width, rect.height / canvas.height);
    const offsetX = (rect.width - canvas.width * scale) / 2;
    const offsetY = (rect.height - canvas.height * scale) / 2;
    mouse.x = (e.clientX - rect.left - offsetX) / scale;
    mouse.y = (e.clientY - rect.top - offsetY) / scale;
    if (gameState === 'PLAY' && Date.now() > aimModeLockUntil) {
        aimMode = 'mouse';
        updateCanvasCursor();
    }
});

// MOUSE DOWN/UP FOR CLICK-TO-CONTINUE
window.addEventListener('mousedown', e=>{ mouse.down = true; });
window.addEventListener('mouseup', e=>{ mouse.down = false; });

/* --- DEV CONSOLE SCRIPTS --- */
function updatePlayerStat(stat, val) {
    player[stat] = parseFloat(val);
    addFloat(`${stat.toUpperCase()} UPDATED`, player.x, player.y, "#00f2fe");
}

function devSkipWave() {
    if(gameState !== "PLAY" || portal.active) return;
    enemies.forEach(e => {
        // Clamp enemy position to map bounds to prevent XP orbs from spawning outside
        const clampedX = Math.max(20, Math.min(ROOM_WIDTH - 20, e.x));
        const clampedY = Math.max(20, Math.min(ROOM_HEIGHT - 20, e.y));
        
        for(let i=0;i<3;i++) xpOrbs.push({ 
            x:clampedX, y:clampedY, 
            vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, 
            v: 10, // Fixed XP value for all orbs
            color: "#00f2fe" // Always blue - original functionality
        });
    });
    enemies = [];
    addFloat("WAVE WIPED", player.x, player.y, "#ff9900");
    if (wave >= WAVES_PER_DEPTH) {
        portal.active = true;
        portal.x = ROOM_WIDTH / 2;
        portal.y = ROOM_HEIGHT / 2;
        addFloat("PORTAL OPEN", portal.x, portal.y - 120, "#00ffaa");
    } else {
        spawnNextWave(); // Immediate spawn when spamming skip
    }
}

function devNextZone() {
    if(gameState !== "PLAY") return;
    enemies = [];
    depthIndex++;
    if(depthIndex >= DEPTH_NAMES.length) depthIndex = 0;
    showZoneIntro();
}

function devUnlockAll() {
    player.hasShock = true;
    player.hasMag = true;
    player.hasShield = true;
    player.shieldUp = true;
    player.hasMulti = true;
    updateSkillUI();
    addFloat("MODULES UNLOCKED", player.x, player.y, "#ff00de");
}

function devSetDepth(newDepth) {
    if(gameState !== "PLAY") return;
    
    const depth = parseInt(newDepth);
    if(isNaN(depth) || depth < 0 || depth > 6) {
        addFloat("INVALID DEPTH (0-6)", player.x, player.y, "#ff2a6d");
        return;
    }
    
    enemies = [];
    depthIndex = depth;
    showZoneIntro();
    addFloat(`DEPTH SET TO ${depth}`, player.x, player.y, "#00f2fe");
}

function devInstantLevel() {
    if(gameState !== "PLAY") return;
    player.xp = player.req;
    checkLevelUp();
    addFloat("LEVEL UP READY", player.x, player.y, "#00ffaa");
}

// Monkey Patch Trivia for Skip
const originalStartTrivia = startTrivia;
startTrivia = function() {
    const skip = document.getElementById('dev-trivia').checked;
    if(skip) {
        // Skip trivia logic, go straight to upgrade
        // Logic copied from checkAnswer(true)
        const unacquired = abilitiesDB.filter(a => {
            if(a.id==='shock' && player.hasShock) return false;
            if(a.id==='mag' && player.hasMag) return false;
            if(a.id==='multi' && player.hasMulti) return false;
            if(a.id==='shield' && player.hasShield) return false;
            return true;
        });

        if(player.lvl % 4 === 0 && unacquired.length > 0) triggerUnlock(unacquired);
        else triggerUpgrade();
    } else {
        originalStartTrivia();
    }
};

// Dev Update Loop Hook
window.devUpdate = function() {
    const isGod = document.getElementById('dev-god').checked;
    if(isGod && gameState === "PLAY") {
        // Instant Reload
        player.cd = 0;
        // Instant Skill Charge
        if(player.hasShock) player.shockTimer = player.shockMax;
        if(player.hasMag && player.magActive <= 0) player.magTimer = player.magMax;
        if(player.hasMulti && player.multiActive <= 0) player.multiTimer = player.multiMax;
        if(player.hasShield && !player.shieldUp) player.shieldTimer = 0; // Will trigger auto recharge logic in update
        player.hp = player.maxHp;
    }
};

applyCanvasResolution();
renderBackground();

</script>
</body>
</html>